<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Dove of Hope">
<meta name="mobile-web-app-capable" content="yes">
<meta name="application-name" content="Dove of Hope">
<meta name="msapplication-TileColor" content="#667eea">
<meta name="msapplication-TileImage" content="./icon-144x144.png">
<title>Dove of Hope : Sky Blessing</title>
<!-- PWA Icons -->
<link rel="icon" type="image/png" sizes="16x16" href="./favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="./favicon-32x32.png">
<link rel="icon" type="image/png" sizes="48x48" href="./favicon-48x48.png">
<link rel="apple-touch-icon" sizes="180x180" href="./apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="192x192" href="./icon-192x192.png">
<link rel="icon" type="image/png" sizes="512x512" href="./icon-512x512.png">
<link rel="manifest" href="./manifest.json">
<meta name="theme-color" content="#667eea">
<meta name="description" content="Vole petite colombe avec courage. Ton cÅ“ur est bon, persÃ©vÃ¨re. N'abandonne jamais!">
<script src="bible-verses.js"></script>
<script src="js/translations/fr.js"></script>
<script src="js/translations/en.js"></script>
<script src="js/translations/es.js"></script>
<script src="js/translations/de.js"></script>
<script src="js/translations/it.js"></script>
<script src="js/translations/pt.js"></script>
<script src="js/translations/ru.js"></script>
<script src="js/translations/ar.js"></script>
<script src="js/translations/hi.js"></script>
<script src="js/translations/ja.js"></script>
<script src="js/translations/ko.js"></script>
<script src="js/translations/zh.js"></script>
<script src="js/translations/sw.js"></script>
<script src="js/translations/pl.js"></script>
<script src="js/testimonies.js"></script>
<!-- Modules de progression -->
<script src="js/levels/level-definitions.js"></script>
<script src="js/levels/level-messages.js"></script>
<script src="js/levels/bible-verses.js"></script>
<script src="js/levels/progression-system.js"></script>
<!-- Module de boss -->
<script src="js/bosses/boss-system.js"></script>
<style>
* {
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
}
body{margin:0;padding:0;background:linear-gradient(135deg,#e8eef2 0%,#d4dce3 50%,#c5d0d8 100%);font-family:Arial,sans-serif;overflow:hidden;touch-action:none;position:fixed;width:100%;height:100%}
#gameContainer{position:relative;width:100vw;height:100vh;max-width:480px;margin:0 auto;background:linear-gradient(180deg,#87ceeb 0%,#b8d8f8 100%);display:flex;align-items:center;justify-content:center}
#gameCanvas{display:block;cursor:none;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);max-width:100%;max-height:100%;z-index:10}
.landscape{position:absolute;bottom:0;left:0;right:0;height:100vh;background:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 300'%3E%3Cpolygon points='0,300 80,240 160,300' fill='%23f8f9fa' opacity='0.5'/%3E%3Cpolygon points='120,300 200,240 280,300' fill='%23ffffff' opacity='0.8'/%3E%3Cpolygon points='240,300 320,240 400,300' fill='%23f8f9fa' opacity='0.5'/%3E%3Cpolygon points='60,300 140,260 220,300' fill='%23ecf0f1' opacity='0.4'/%3E%3Cpolygon points='180,300 260,260 340,300' fill='%23ecf0f1' opacity='0.4'/%3E%3C/svg%3E") no-repeat bottom center/cover;pointer-events:none;z-index:1}
#ui{position:absolute;top:0;left:0;right:0;color:#2c3e50;font-weight:600;z-index:100;font-size:11px;background:linear-gradient(180deg,rgba(255,255,255,0.92) 0%,rgba(255,255,255,0.8) 90%,rgba(255,255,255,0) 100%);backdrop-filter:blur(10px);padding:4px 10px;box-shadow:0 1px 6px rgba(0,0,0,0.08);display:flex;justify-content:space-between;align-items:center;gap:8px}
#ui > div{display:flex;align-items:center;gap:3px;color:#34495e;white-space:nowrap}
#ui > div span{font-weight:900;color:#2c3e50;font-size:13px}
#ui .ui-section{display:flex;align-items:center;gap:8px}
#message{position:absolute;top:20%;left:50%;transform:translate(-50%,-50%);color:#000000;font-size:18px;font-weight:bold;text-align:center;opacity:0;transition:opacity 0.5s;-webkit-text-stroke:2px white;paint-order:stroke fill;z-index:200;max-width:90%;padding:15px;word-wrap:break-word;overflow-wrap:break-word;white-space:normal;line-height:1.4}
#startButton{position:absolute;bottom:80px;left:50%;transform:translateX(-50%);width:90px;height:110px;background:linear-gradient(180deg,transparent 0%,transparent 50%,#34495e 50%,#2c3e50 100%);border:3px solid #2c3e50;border-radius:50% 50% 50% 50%/60% 60% 40% 40%;cursor:pointer;transition:all 0.5s;overflow:visible;z-index:300;box-shadow:0 5px 15px rgba(0,0,0,0.3)}
#startButton.hidden{opacity:0;pointer-events:none;transform:translateX(-50%) scale(0.5)}
#startButton::before{content:'ğŸ’¡';position:absolute;top:40%;left:50%;transform:translate(-50%,-50%);font-size:42px;animation:bulbGlow 2s infinite;filter:drop-shadow(0 0 10px rgba(255,235,59,0.6))}
#startButton::after{content:'O/I';position:absolute;bottom:18px;left:50%;transform:translateX(-50%);color:white;font-size:14px;font-weight:bold;text-shadow:0 2px 4px rgba(0,0,0,0.8);letter-spacing:2px}
#startButton:hover,#startButton:active{transform:translateX(-50%) translateY(-8px) scale(1.05);box-shadow:0 15px 35px rgba(52,152,219,0.5),0 0 20px rgba(255,235,59,0.4)}
#startButton:hover::before,#startButton:active::before{font-size:48px;filter:drop-shadow(0 0 20px rgba(255,235,59,1))}
.sun{position:absolute;top:15%;right:50px;transform:translateY(-50%);width:60px;height:60px;border-radius:50%;transition:all 0.4s ease;z-index:5}
.sun::before{content:'';position:absolute;top:-10px;left:-10px;right:-10px;bottom:-10px;border-radius:50%;border:3px solid;opacity:0.5;animation:rays 4s infinite linear}
.sun::after{content:'';position:absolute;top:-5px;left:-5px;right:-5px;bottom:-5px;border-radius:50%;border:2px dashed;opacity:0.3;animation:rays 6s infinite linear reverse}
.sun.happy{background:radial-gradient(circle,#fff9c4 0%,#ffeb3b 40%,#ffc107 70%,#ff9800 100%);box-shadow:0 0 40px rgba(255,193,7,0.8),0 0 20px rgba(255,235,59,0.6);animation:glow 2s infinite}
.sun.happy::before{border-color:#ffc107;opacity:0.7}
.sun.happy::after{border-color:#ffeb3b}
.sun.sad{background:radial-gradient(circle,#ecf0f1 0%,#bdc3c7 60%,#95a5a6 100%);box-shadow:0 0 15px rgba(149,165,166,0.5)}
.sun.sad::before{border-color:#95a5a6;opacity:0.3;animation:none}
.sun.sad::after{display:none}
.sun.neutral{background:radial-gradient(circle,#fdeaa7 0%,#f39c12 60%,#e67e22 100%);box-shadow:0 0 25px rgba(243,156,18,0.6)}
.sun.neutral::before{border-color:#f39c12;opacity:0.5;animation:rays 6s infinite linear}
.motivation{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#2c3e50;font-size:13px;text-align:center;font-weight:600;text-shadow:none;opacity:0.95;transition:all 0.5s;max-width:85%;padding:12px 20px;background:rgba(255,255,255,0.95);border-radius:20px;z-index:250;backdrop-filter:blur(5px);border:2px solid #e0e0e0;box-shadow:0 4px 15px rgba(0,0,0,0.15)}
.motivation.compact{bottom:220px;top:auto;transform:translateX(-50%);font-size:11px;max-width:80%;padding:8px 15px;opacity:0;pointer-events:none;visibility:hidden}
@keyframes bulbGlow{0%,100%{opacity:0.7;transform:translate(-50%,-50%) scale(1)}50%{opacity:1;transform:translate(-50%,-50%) scale(1.15);filter:drop-shadow(0 0 15px rgba(255,235,59,0.9))}}
@keyframes fadeOut{0%,75%{opacity:1}100%{opacity:0}}
@keyframes rays{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
@keyframes glow{0%,100%{transform:scale(1)}50%{transform:scale(1.05)}}

.audio-controls{display:flex;gap:3px;z-index:150}
.audio-btn{width:20px;height:20px;border-radius:50%;background:rgba(255,255,255,0.85);border:1.5px solid #3498db;cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:11px;line-height:1;transition:all 0.3s;box-shadow:0 1px 3px rgba(0,0,0,0.1)}
.audio-btn:hover{transform:scale(1.08);box-shadow:0 2px 6px rgba(52,152,219,0.3)}
.audio-btn.muted{background:rgba(231,76,60,0.85);border-color:#c0392b}
.audio-btn.muted:hover{box-shadow:0 2px 6px rgba(231,76,60,0.3)}

@media (min-width: 600px) {
  #gameContainer{max-width:480px;box-shadow:0 0 20px rgba(0,0,0,0.2)}
}

@media (max-width: 480px) {
  #gameContainer{max-width:100vw}
  #ui{font-size:10px;padding:3px 8px;gap:6px}
  #ui > div span{font-size:12px}
  #message{font-size:16px;padding:12px;max-width:92%}
  .motivation{font-size:12px;padding:10px 16px;max-width:88%}
  #startButton{width:80px;height:100px;bottom:70px}
  #startButton::before{font-size:38px}
  #startButton::after{font-size:12px;bottom:15px}
  .sun{width:50px;height:50px;right:30px;top:12%}
}

@media (max-width: 360px) {
  /* Optimisation pour iPhone SE et trÃ¨s petits Ã©crans */
  #ui{font-size:9px;padding:2px 6px;gap:4px;flex-wrap:wrap}
  #ui > div{gap:2px}
  #ui > div span{font-size:11px}
  #message{font-size:14px;padding:10px;-webkit-text-stroke:1.5px white}
  .motivation{font-size:11px;padding:8px 12px;max-width:90%}
  #startButton{width:70px;height:90px;bottom:60px}
  #startButton::before{font-size:32px}
  #startButton::after{font-size:10px;bottom:12px}
  .sun{width:45px;height:45px;right:25px;top:10%}
  .audio-btn{width:18px;height:18px;font-size:10px}
  button[onclick*="pauseMenu"]{width:35px;height:35px;font-size:10px;top:60px}
  #pauseMenu{padding:8px;top:60px}
}

@media (max-width: 320px) {
  /* ExtrÃªme optimisation pour trÃ¨s anciens appareils */
  #ui{font-size:8px;padding:2px 4px;gap:3px}
  #ui > div span{font-size:10px}
  #message{font-size:13px;padding:8px;line-height:1.3}
  .motivation{font-size:10px;padding:6px 10px}
  #startButton{width:65px;height:85px;bottom:55px}
  #startButton::before{font-size:28px}
  #startButton::after{font-size:9px;bottom:10px;letter-spacing:1px}
  .sun{width:40px;height:40px;right:20px}
  .audio-btn{width:16px;height:16px;font-size:9px}
  button[onclick*="pauseMenu"]{width:32px;height:32px;font-size:9px;top:55px;left:8px}
  #pauseMenu{padding:6px;top:55px;left:8px}
  #pauseMenu button{width:35px;height:35px;font-size:10px}
  #pauseMenu > div > div{font-size:18px;padding:6px}
  #pauseMenu #difficultyLabel{font-size:10px}
  #pauseMenu [id^="diffBtn_"]{font-size:9px;padding:5px 3px}
}

</style>

<!-- BibliothÃ¨que Supabase pour sauvegarde en ligne -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="supabase-config-dove.js"></script>

</head>
<body>
<div id="gameContainer">
<canvas id="gameCanvas"></canvas>
<div class="landscape"></div>
<div class="sun neutral" id="sun"></div>

<!-- Menu Pause -->
<div id="pauseMenu" style="position:absolute;top:70px;left:10px;background:rgba(255,255,255,0.95);border-radius:12px;box-shadow:0 4px 15px rgba(0,0,0,0.3);padding:6px;z-index:10000;display:none;width:45px;">
  
  <!-- IcÃ´nes en colonne compacte -->
  <div style="display:flex;flex-direction:column;gap:4px;">
    <!-- Fermer -->
    <div data-action="close" style="cursor:pointer;font-size:18px;padding:6px;border-radius:8px;transition:all 0.2s;background:rgba(231,76,60,0.1);text-align:center;display:flex;align-items:center;justify-content:center;" onmouseover="this.style.background='rgba(231,76,60,0.3)'" onmouseout="this.style.background='rgba(231,76,60,0.1)'" title="Fermer">âœ•</div>
    
    <!-- Pause -->
    <div data-action="pause" style="cursor:pointer;font-size:18px;padding:6px;border-radius:8px;transition:all 0.2s;background:rgba(231,76,60,0.1);text-align:center;display:flex;align-items:center;justify-content:center;" onmouseover="this.style.background='rgba(231,76,60,0.2)'" onmouseout="this.style.background='rgba(231,76,60,0.1)'" title="Pause">â¸</div>

    <!-- Musique -->
    <div class="audio-btn" id="musicBtn" style="cursor:pointer;font-size:18px;padding:6px;border-radius:8px;transition:all 0.2s;background:rgba(155,89,182,0.1);text-align:center;display:flex;align-items:center;justify-content:center;" onmouseover="this.style.background='rgba(155,89,182,0.2)'" onmouseout="this.style.background='rgba(155,89,182,0.1)'" title="Musique">ğŸµ</div>
    
    <!-- SFX -->
    <div class="audio-btn" id="sfxBtn" style="cursor:pointer;font-size:18px;padding:6px;border-radius:8px;transition:all 0.2s;background:rgba(155,89,182,0.1);text-align:center;display:flex;align-items:center;justify-content:center;" onmouseover="this.style.background='rgba(155,89,182,0.2)'" onmouseout="this.style.background='rgba(155,89,182,0.1)'" title="Effets">ğŸ”Š</div>

    <!-- Installer PWA -->
    <div id="installBtnMenu" onclick="triggerPWAInstall()" style="cursor:pointer;font-size:18px;padding:6px;border-radius:8px;transition:all 0.2s;background:rgba(102,126,234,0.15);text-align:center;display:flex;align-items:center;justify-content:center;" onmouseover="this.style.background='rgba(102,126,234,0.3)'" onmouseout="this.style.background='rgba(102,126,234,0.15)'" title="Installer">ğŸ“²</div>

    <!-- SÃ©parateur -->
    <div style="height:1px;background:rgba(0,0,0,0.1);margin:2px 0;"></div>

    <!-- DifficultÃ© icÃ´nes -->
    <div id="diffBtn_easy" onclick="changeDifficulty('easy')" style="cursor:pointer;font-size:18px;padding:6px;border-radius:8px;transition:all 0.2s;background:rgba(46,204,113,0.15);text-align:center;display:flex;align-items:center;justify-content:center;" onmouseover="this.style.background='rgba(46,204,113,0.3)'" onmouseout="this.style.background='rgba(46,204,113,0.15)'" title="Facile">ğŸŸ¢</div>
    
    <div id="diffBtn_normal" onclick="changeDifficulty('normal')" style="cursor:pointer;font-size:18px;padding:6px;border-radius:8px;transition:all 0.2s;background:rgba(52,152,219,0.15);text-align:center;border:2px solid rgba(52,152,219,0.5);display:flex;align-items:center;justify-content:center;" onmouseover="this.style.background='rgba(52,152,219,0.3)'" onmouseout="this.style.background='rgba(52,152,219,0.15)'" title="Normal">ğŸ”µ</div>
    
    <div id="diffBtn_hard" onclick="changeDifficulty('hard')" style="cursor:pointer;font-size:18px;padding:6px;border-radius:8px;transition:all 0.2s;background:rgba(230,126,34,0.15);text-align:center;display:flex;align-items:center;justify-content:center;" onmouseover="this.style.background='rgba(230,126,34,0.3)'" onmouseout="this.style.background='rgba(230,126,34,0.15)'" title="Difficile">ğŸŸ </div>
    
    <div id="diffBtn_legendary" onclick="changeDifficulty('legendary')" style="cursor:pointer;font-size:18px;padding:6px;border-radius:8px;transition:all 0.2s;background:rgba(142,68,173,0.15);text-align:center;display:flex;align-items:center;justify-content:center;" onmouseover="this.style.background='rgba(142,68,173,0.3)'" onmouseout="this.style.background='rgba(142,68,173,0.15)'" title="LÃ©gendaire">ğŸŸ£</div>
  </div>
</div>

<!-- Overlay pour fermer le menu en cliquant dehors -->
<div id="pauseMenuOverlay" onclick="document.getElementById('pauseMenu').style.display='none'; this.style.display='none'" style="position:absolute;top:0;left:0;width:100%;height:100%;z-index:9999;display:none;"></div>

<!-- Bouton pour ouvrir le menu -->
<button onclick="document.getElementById('pauseMenu').style.display='block'; document.getElementById('pauseMenuOverlay').style.display='block'" style="position:absolute;top:70px;left:10px;width:40px;height:40px;border-radius:50%;background:rgba(255,255,255,0.95);border:2px solid rgba(0,0,0,0.1);font-size:11px;font-weight:bold;cursor:pointer;box-shadow:0 4px 10px rgba(0,0,0,0.2);z-index:140;transition:all 0.3s;" onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'" title="Menu">O/I</button>

<div id="ui" style="position:absolute;top:10px;left:20px;right:20px;display:flex;justify-content:center;align-items:center;background:rgba(255,255,255,0.7);padding:6px 20px;border-radius:8px;box-shadow:0 4px 15px rgba(0,0,0,0.1);backdrop-filter:blur(10px);transition:opacity 0.3s, transform 0.3s;z-index:100;">
<div style="display:flex;gap:15px;align-items:center;flex:1;justify-content:center;">
<div style="font-weight:700;color:#667eea;font-size:18px;"><span id="score">0</span> <span style="font-size:12px;opacity:0.7;">pts</span></div>
<div style="color:#3498db;font-weight:600;">â˜ï¸ <span id="clouds">0</span></div>
<div style="color:#9b59b6;font-weight:600;"><span id="levelLabel"></span> <span id="level">1</span></div>
<div style="color:#e74c3c;font-weight:600;"><span id="lives">3</span> â¤ï¸</div>
<div style="color:#f39c12;font-weight:600;">â­ <span id="starStock">0</span></div>
</div>
<div onclick="showStats();" style="cursor:pointer;font-size:20px;padding:4px 8px;border-radius:8px;transition:all 0.2s;background:rgba(52,152,219,0.15);" onmouseover="this.style.background='rgba(52,152,219,0.3)'" onmouseout="this.style.background='rgba(52,152,219,0.15)'" title="Mes TrÃ©sors">ğŸ’</div>
<div id="langFlag" onclick="showLanguageSelector();" style="cursor:pointer;font-size:20px;padding:4px 8px;border-radius:8px;transition:all 0.2s;background:rgba(243,156,18,0.15);" onmouseover="this.style.background='rgba(243,156,18,0.3)'" onmouseout="this.style.background='rgba(243,156,18,0.15)'" title="Changer de langue">ğŸ‡«ğŸ‡·</div>
</div>
<div id="message"></div>
<button id="startButton"></button>
<div class="motivation" id="motivationText"></div>
</div>

<style>
#message {
  position: absolute;
  top: 80px;
  left: 50%;
  transform: translateX(-50%);
  background: transparent;
  color: #333;
  padding: 10px 20px;
  border-radius: 20px;
  font-size: 16px;
  font-weight: 600;
  letter-spacing: 0.3px;
  text-shadow: 
    -1px -1px 0 #fff,
    1px -1px 0 #fff,
    -1px 1px 0 #fff,
    1px 1px 0 #fff,
    0 0 8px rgba(255,255,255,0.8);
  z-index: 300;
  max-width: 80%;
  text-align: center;
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  line-height: 1.4;
  word-wrap: break-word;
}
</style>

<script>
// ============================================
// ğŸŒ SYSTEM DE TRADUCTION MULTILINGUE
// ============================================

// CrÃ©er l'objet LANGUAGES Ã  partir des constantes individuelles
const LANGUAGES = {
  fr, en, es, de, it, pt, ru, ar, hi, ja, ko, zh, sw, pl
};

// Fonction pour obtenir une traduction par chemin (ex: "ui.score")
function getTranslation(langCode, key) {
  const lang = LANGUAGES[langCode];
  if (!lang) return null;
  
  const keys = key.split('.');
  let value = lang;
  
  for (const k of keys) {
    if (value && typeof value === 'object') {
      value = value[k];
    } else {
      return null;
    }
  }
  
  return value;
}

// VÃ©rifier si une langue existe
function languageExists(langCode) {
  return !!LANGUAGES[langCode];
}

// ============================================
// SYSTÃˆME DE TRADUCTION (utilise translations.js)
// ============================================

let menuVisible = true;
let menuHideTimeout = null;
let pausedState = null;

function togglePause() {
  const ui = document.getElementById('ui');
  const toggleBtn = document.getElementById('menuToggle');

  if (state === 'playing') {
    // Mettre en pause
    pausedState = state;
    state = 'paused';
  } else if (state === 'paused') {
    // Reprendre le jeu
    state = pausedState || 'playing';
    pausedState = null;
  }
}

// DifficultÃ© actuelle (par dÃ©faut: normal)
let currentDifficulty = 'normal';

// Multiplicateurs de difficultÃ©
const DIFFICULTY_MULTIPLIERS = {
  easy: {
    cloudSpeed: 0.7,
    cloudSpawnRate: 0.7,
    shootingClouds: 0.7,
    rainSpeed: 0.8,
    powerUpRate: 1.3
  },
  normal: {
    cloudSpeed: 1.0,
    cloudSpawnRate: 1.0,
    shootingClouds: 1.0,
    rainSpeed: 1.0,
    powerUpRate: 1.0
  },
  hard: {
    cloudSpeed: 1.3,
    cloudSpawnRate: 1.3,
    shootingClouds: 1.2,
    rainSpeed: 1.2,
    powerUpRate: 0.8
  },
  legendary: {
    cloudSpeed: 1.6,
    cloudSpawnRate: 1.5,
    shootingClouds: 1.4,
    rainSpeed: 1.4,
    powerUpRate: 0.6
  }
};

// Fonction pour changer de difficultÃ©
function changeDifficulty(difficulty) {
  if (!DIFFICULTY_MULTIPLIERS[difficulty]) return;

  currentDifficulty = difficulty;
  localStorage.setItem('doveGameDifficulty', difficulty);

  // Mettre Ã  jour l'affichage des boutons
  updateDifficultyButtons();

  // Afficher un message
  msg(t('ui.difficulty_changed') + ' : ' + t('ui.' + difficulty));

}

// Fonction pour mettre Ã  jour l'affichage des boutons de difficultÃ©
function updateDifficultyButtons() {
  const difficulties = ['easy', 'normal', 'hard', 'legendary'];

  difficulties.forEach(diff => {
    const btn = document.getElementById('diffBtn_' + diff);
    if (btn) {
      if (diff === currentDifficulty) {
        btn.style.border = '2px solid rgba(52,152,219,0.8)';
        btn.style.transform = 'scale(1.1)';
      } else {
        btn.style.border = 'none';
        btn.style.transform = 'scale(1)';
      }
    }
  });
}

// Fonction pour mettre Ã  jour les textes de difficultÃ© selon la langue
function updateDifficultyTexts() {
  // Ne plus modifier les boutons de difficultÃ© car ils utilisent des icÃ´nes
  // Les icÃ´nes sont: ğŸŸ¢ Facile, ğŸ”µ Normal, ğŸŸ  Difficile, ğŸŸ£ LÃ©gendaire
}

// Fonction pour obtenir une valeur ajustÃ©e selon la difficultÃ©
function applyDifficulty(paramName, baseValue) {
  const multiplier = DIFFICULTY_MULTIPLIERS[currentDifficulty];
  if (!multiplier || !multiplier[paramName]) return baseValue;

  // Pour les objets avec min/max (vitesses)
  if (typeof baseValue === 'object' && baseValue.min !== undefined && baseValue.max !== undefined) {
    return {
      min: baseValue.min * multiplier[paramName],
      max: baseValue.max * multiplier[paramName]
    };
  }

  // Pour les valeurs simples
  return baseValue * multiplier[paramName];
}

// Masquer le menu automatiquement aprÃ¨s le dÃ©marrage du jeu
function autoHideMenuOnStart() {
  // DÃ©sactivÃ© - le menu reste toujours visible
}

// Langue actuelle (par dÃ©faut: franÃ§ais)
let currentLang = 'fr';

// Fonction pour changer de langue
function setLanguage(langCode) {
  if (languageExists(langCode)) {
    currentLang = langCode;
    localStorage.setItem('doveGameLang', langCode);
    updateUILanguage();
  }
}

// Fonction pour obtenir une traduction
function t(key, params = {}) {
  let value = getTranslation(currentLang, key);
  
  if (!value) return key;
  
  // Remplacer les paramÃ¨tres {param}
  if (typeof value === 'string') {
    Object.keys(params).forEach(param => {
      value = value.replace(new RegExp(`\\{${param}\\}`, 'g'), params[param]);
    });
  }
  
  return value;
}

// Fonction pour mettre Ã  jour la langue de l'interface
function updateUILanguage() {
  // Mettre Ã  jour le label de niveau dans la barre de statut
  const levelLabel = document.getElementById('levelLabel');
  if (levelLabel) {
    levelLabel.textContent = t('ui.level').substring(0, 4) + '.';
  }

  // Mettre Ã  jour les textes de difficultÃ©
  updateDifficultyTexts();

  // Mettre Ã  jour le bouton d'installation
  const installBtnText = document.getElementById('installBtnText');
  if (installBtnText) {
    installBtnText.textContent = t('ui.install') || 'INSTALLER';
  }

  // Mettre Ã  jour les tooltips du menu O/I
  updateMenuTooltips();

  // Mettre Ã  jour les textes de l'UI si nÃ©cessaire
  if (state === 'start' || state === 'gameOver') {
    // Recharger l'Ã©cran
  }
}

// Fonction pour mettre Ã  jour les tooltips du menu
function updateMenuTooltips() {
  const pauseMenu = document.getElementById('pauseMenu');
  if (pauseMenu) {
    const buttons = pauseMenu.querySelectorAll('[title]');
    buttons.forEach(btn => {
      const currentTitle = btn.getAttribute('title');
      // Identifier le bouton et mettre Ã  jour son tooltip
      if (btn.textContent.includes('âœ•')) btn.setAttribute('title', t('ui.close') || 'Fermer');
      else if (btn.textContent.includes('â¸')) btn.setAttribute('title', t('ui.pause') || 'Pause');
      else if (btn.id === 'musicBtn') btn.setAttribute('title', t('ui.music') || 'Musique');
      else if (btn.id === 'sfxBtn') btn.setAttribute('title', t('ui.sfx') || 'Effets');
      else if (btn.id === 'installBtnMenu') btn.setAttribute('title', t('ui.install_app') || 'Installer');
      else if (btn.id === 'diffBtn_easy') btn.setAttribute('title', t('ui.easy') || 'Facile');
      else if (btn.id === 'diffBtn_normal') btn.setAttribute('title', t('ui.normal') || 'Normal');
      else if (btn.id === 'diffBtn_hard') btn.setAttribute('title', t('ui.hard') || 'Difficile');
      else if (btn.id === 'diffBtn_legendary') btn.setAttribute('title', t('ui.legendary') || 'LÃ©gendaire');
    });
  }
  
  // Mettre Ã  jour le bouton O/I
  const menuBtn = document.querySelector('[title="Menu"]');
  if (menuBtn) menuBtn.setAttribute('title', t('ui.menu') || 'Menu');
}

// Charger la langue sauvegardÃ©e
const savedLang = localStorage.getItem('doveGameLang');
if (savedLang && languageExists(savedLang)) {
  currentLang = savedLang;
}

// Charger la difficultÃ© sauvegardÃ©e
const savedDifficulty = localStorage.getItem('doveGameDifficulty');
if (savedDifficulty && DIFFICULTY_MULTIPLIERS[savedDifficulty]) {
  currentDifficulty = savedDifficulty;
}

// Fonction pour obtenir le drapeau de la langue actuelle
function getCurrentLanguageFlag() {
  const flags = {
    'fr': 'ğŸ‡«ğŸ‡·', 'en': 'ğŸ‡¬ğŸ‡§', 'es': 'ğŸ‡ªğŸ‡¸', 'pt': 'ğŸ‡µğŸ‡¹',
    'de': 'ğŸ‡©ğŸ‡ª', 'it': 'ğŸ‡®ğŸ‡¹', 'nl': 'ğŸ‡³ğŸ‡±', 'ru': 'ğŸ‡·ğŸ‡º',
    'ar': 'ğŸ‡¸ğŸ‡¦', 'zh': 'ğŸ‡¨ğŸ‡³', 'ja': 'ğŸ‡¯ğŸ‡µ', 'ko': 'ğŸ‡°ğŸ‡·',
    'hi': 'ğŸ‡®ğŸ‡³', 'tr': 'ğŸ‡¹ğŸ‡·'
  };
  return flags[currentLang] || 'ğŸŒ';
}

// Mettre Ã  jour le drapeau dans l'UI
function updateLanguageFlag() {
  const langFlagEl = document.getElementById('langFlag');
  if (langFlagEl) {
    langFlagEl.textContent = getCurrentLanguageFlag();
  }
  
  // Mettre Ã  jour le texte de motivation
  const motivationEl = document.getElementById('motivationText');
  if (motivationEl && typeof t === 'function') {
    motivationEl.textContent = '"' + t('intro') + '"';
  }
  
  // Mettre Ã  jour le tÃ©moignage
  updateTestimonyContent();
}

// Fonction pour mettre Ã  jour le contenu du tÃ©moignage
function updateTestimonyContent() {
  if (typeof t !== 'function') return;
  
  const titleEl = document.getElementById('testimonyTitleText');
  const paragraphsEl = document.getElementById('testimonyParagraphs');
  
  if (titleEl) {
    titleEl.textContent = t('testimony.title');
  }
  
  if (paragraphsEl) {
    paragraphsEl.innerHTML = `
      <p style="margin:10px 0;">${t('testimony.paragraph1')}</p>
      <p style="margin:10px 0;">${t('testimony.paragraph2')}</p>
      <p style="margin:10px 0;">${t('testimony.paragraph3')}</p>
      <p style="margin:10px 0;">${t('testimony.paragraph4')}</p>
      <p style="margin:10px 0;">${t('testimony.paragraph5')}</p>
      <p style="margin:10px 0;">${t('testimony.paragraph6')}</p>
      <p style="margin:10px 0;text-align:center;font-weight:bold;color:#fff;font-size:14px;padding:10px;background:rgba(255,255,255,0.2);border-radius:8px;">
        ${t('testimony.final_message')}
      </p>
    `;
  }
}

function showTestimonies() {
  const lang = currentLang || 'fr';

  // VÃ©rifier si les fonctions sont disponibles
  if (typeof getTestimonies !== 'function' || typeof getTestimonyTitle !== 'function') {
      alert('Erreur: Le module de tÃ©moignages n\'est pas chargÃ©. Veuillez recharger la page.');
    return;
  }

  const testimonies = getTestimonies(lang);
  const testimonyTitle = getTestimonyTitle(lang);
  
  const testimonyDiv = document.createElement('div');
  testimonyDiv.id = 'testimonyDisplay';
  testimonyDiv.style.cssText = `
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90%;
    max-width: 500px;
    max-height: 85vh;
    background: linear-gradient(135deg, rgba(231,76,60,0.98) 0%, rgba(241,196,15,0.98) 100%);
    color: white;
    padding: 30px;
    border-radius: 20px;
    box-shadow: 0 10px 50px rgba(0,0,0,0.5);
    z-index: 500;
    overflow-y: auto;
  `;
  
  testimonyDiv.innerHTML = `
    <button onclick="document.getElementById('testimonyDisplay').remove()" style="position:absolute;top:10px;right:10px;background:rgba(0,0,0,0.3);color:white;border:none;border-radius:50%;width:35px;height:35px;font-size:20px;cursor:pointer;font-weight:bold;line-height:1;">âœ•</button>
    <h2 style="text-align:center;margin-bottom:20px;font-size:24px;">${testimonyTitle}</h2>
    
    ${testimonies.map((testimony, index) => `
      <div style="margin-bottom:15px;">
        <button onclick="const content=this.nextElementSibling;const arrow=this.querySelector('span');if(content.style.display==='none'||content.style.display===''){content.style.display='block';arrow.textContent='â–¼';}else{content.style.display='none';arrow.textContent='â–¶';}" 
          style="width:100%;text-align:left;background:rgba(255,255,255,0.2);border:2px solid rgba(255,255,255,0.3);color:white;padding:15px;border-radius:10px;font-size:16px;font-weight:bold;cursor:pointer;display:flex;align-items:center;gap:10px;transition:all 0.3s;"
          onmouseover="this.style.background='rgba(255,255,255,0.3)'"
          onmouseout="this.style.background='rgba(255,255,255,0.2)'">
          <span style="font-size:12px;">â–¶</span>
          <span style="flex:1;">âœ¨ ${testimony.title}</span>
        </button>
        <div style="display:none;background:rgba(255,255,255,0.15);padding:20px;border-radius:0 0 10px 10px;margin-top:-5px;border:2px solid rgba(255,255,255,0.2);border-top:none;">
          <div style="font-size:14px;line-height:1.8;text-align:justify;white-space:pre-line;opacity:0.95;">
            ${testimony.text}
          </div>
          <p style="margin-top:15px;text-align:right;font-style:italic;font-size:13px;opacity:0.8;">â€” ${testimony.author}</p>
        </div>
      </div>
    `).join('')}
    
    <div style="text-align:center;margin-top:20px;">
      <button onclick="document.getElementById('testimonyDisplay').remove()" style="
        padding:12px 24px;
        background:#27ae60;
        color:white;
        border:none;
        border-radius:10px;
        font-size:16px;
        font-weight:bold;
        cursor:pointer;
        box-shadow:0 4px 6px rgba(0,0,0,0.2);
        transition:transform 0.2s;
      " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
        ${t('buttons.close')}
      </button>
    </div>
  `;
  
  document.body.appendChild(testimonyDiv);
}

// Fonction pour afficher le sÃ©lecteur de langue
function showLanguageSelector() {
  const languages = [
    { code: 'fr', name: 'FranÃ§ais', flag: 'ğŸ‡«ğŸ‡·' },
    { code: 'en', name: 'English', flag: 'ğŸ‡¬ğŸ‡§' },
    { code: 'es', name: 'EspaÃ±ol', flag: 'ğŸ‡ªğŸ‡¸' },
    { code: 'pt', name: 'PortuguÃªs', flag: 'ğŸ‡µğŸ‡¹' },
    { code: 'de', name: 'Deutsch', flag: 'ğŸ‡©ğŸ‡ª' },
    { code: 'it', name: 'Italiano', flag: 'ğŸ‡®ğŸ‡¹' },
    { code: 'ru', name: 'Ğ ÑƒÑÑĞºĞ¸Ğ¹', flag: 'ğŸ‡·ğŸ‡º' },
    { code: 'zh', name: 'ä¸­æ–‡', flag: 'ğŸ‡¨ğŸ‡³' },
    { code: 'ar', name: 'Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©', flag: 'ğŸ‡¸ğŸ‡¦' },
    { code: 'hi', name: 'à¤¹à¤¿à¤¨à¥à¤¦à¥€', flag: 'ğŸ‡®ğŸ‡³' },
    { code: 'sw', name: 'Kiswahili', flag: 'ğŸ‡°ğŸ‡ª' },
    { code: 'ko', name: 'í•œêµ­ì–´', flag: 'ğŸ‡°ğŸ‡·' },
    { code: 'ja', name: 'æ—¥æœ¬èª', flag: 'ğŸ‡¯ğŸ‡µ' },
    { code: 'pl', name: 'Polski', flag: 'ğŸ‡µğŸ‡±' }
  ];
  
  const langDiv = document.createElement('div');
  langDiv.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(135deg, rgba(52,152,219,0.95) 0%, rgba(41,128,185,0.95) 100%);
    padding: 25px;
    border-radius: 20px;
    z-index: 9999;
    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    max-width: 400px;
    max-height: 80vh;
    overflow-y: auto;
  `;
  
  langDiv.innerHTML = `
    <button onclick="this.parentElement.remove()" style="position:absolute;top:10px;right:10px;background:rgba(0,0,0,0.3);color:white;border:none;border-radius:50%;width:35px;height:35px;font-size:20px;cursor:pointer;font-weight:bold;line-height:1;">âœ•</button>
    <h2 style="text-align:center;margin-bottom:20px;color:white;font-size:22px;">ğŸŒ ${t('ui.choose_language')}</h2>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
      ${languages.map(lang => `
        <button onclick="selectLanguage('${lang.code}')" style="
          background: ${currentLang === lang.code ? 'rgba(46,204,113,0.9)' : 'rgba(255,255,255,0.9)'};
          border: 3px solid ${currentLang === lang.code ? '#27ae60' : 'transparent'};
          padding: 12px;
          border-radius: 12px;
          cursor: pointer;
          font-size: 14px;
          font-weight: bold;
          color: #2c3e50;
          transition: all 0.3s;
          display: flex;
          align-items: center;
          justify-content: center;
          gap: 8px;
        " onmouseover="this.style.transform='scale(1.05)';" onmouseout="this.style.transform='scale(1)';">
          <span style="font-size:24px;">${lang.flag}</span>
          <span>${lang.name}</span>
        </button>
      `).join('')}
    </div>
  `;
  
  document.body.appendChild(langDiv);
}

// Fonction pour sÃ©lectionner une langue
function selectLanguage(langCode) {
  // PrÃ©parer le message AVANT de changer la langue
  const langNames = {
    'fr': 'FranÃ§ais', 'en': 'English', 'es': 'EspaÃ±ol', 'pt': 'PortuguÃªs',
    'de': 'Deutsch', 'it': 'Italiano', 'ru': 'Ğ ÑƒÑÑĞºĞ¸Ğ¹', 'zh': 'ä¸­æ–‡',
    'ar': 'Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©', 'hi': 'à¤¹à¤¿à¤¨à¥à¤¦à¥€', 'sw': 'Kiswahili', 'ko': 'í•œêµ­ì–´',
    'ja': 'æ—¥æœ¬èª', 'pl': 'Polski'
  };
  
  // Fermer le sÃ©lecteur
  const selector = document.querySelector('div[style*="grid-template-columns"]');
  if (selector && selector.parentElement) {
    selector.parentElement.remove();
  }
  
  // Changer la langue
  setLanguage(langCode);
  
  // Mettre Ã  jour le drapeau dans l'UI
  updateLanguageFlag();
  
  // Afficher un message de confirmation dans la NOUVELLE langue
  msg(`ğŸŒ ${t('ui.language_changed')}: ${langNames[langCode] || langCode.toUpperCase()}`);
}

// ============================================
// ğŸ’¾ SYSTÃˆME DE SAUVEGARDE LOCALE
// ============================================

const SAVE_KEY = 'doveGameSave';

// Structure des donnÃ©es de sauvegarde
// Structure des donnÃ©es de sauvegarde
let gameData = {
  // Progression
  highestLevelReached: 1,
  highScore: 0,
  totalCloudsDestroyed: 0,
  totalGamesPlayed: 0,
  totalPlayTime: 0, // en secondes
  starStock: 0, // Stock d'Ã©toiles accumulÃ©es
  
  // Statistiques
  stats: {
    totalShots: 0,
    totalHits: 0,
    totalMisses: 0,
    totalPowerUpsCollected: 0,
    totalLivesLost: 0,
    longestSurvival: 0,
    perfectLevels: 0,
    deathsByClouds: 0,
    deathsByRain: 0
  },
  
  // Achievements (pour usage futur)
  achievements: [],
  
  // Niveaux bonus
  bonusLevels: {
    completed: [false, false, false, false], // 4 niveaux bonus
    bestScores: [0, 0, 0, 0],
    totalItemsCollected: 0
  },
  
  // Boss vaincus (pour dÃ©verrouiller les sagesses)
  bossesDefeated: {
    spider: false,
    flying_snake: false,
    crazy_chicken: false,
    grim_reaper: false,
    wall: false,
    dark_cloud: false,
    black_raven: false
  },
  
  // DerniÃ¨re session
  lastPlayed: null,
  lastScore: 0,
  lastLevel: 1
};

// Variables globales pour le jeu (dÃ©clarÃ©es avant loadGameData)
let starCount = 0; // Compteur d'Ã©toiles accumulÃ©es
let lastStarChangeTime = 0; // Pour faire disparaÃ®tre le texte rapidement

// Charger les donnÃ©es sauvegardÃ©es
function loadGameData() {
  try {
    const savedData = localStorage.getItem(SAVE_KEY);
    if (savedData) {
      const parsed = JSON.parse(savedData);
      // Fusionner avec la structure par dÃ©faut pour compatibilitÃ©
      gameData = { ...gameData, ...parsed };
      // Restaurer le stock d'Ã©toiles
      if (typeof gameData.starStock !== 'undefined') {
        starCount = gameData.starStock;
      }
              return true;
    }
  } catch (error) {
    }
  return false;
}

// Sauvegarder les donnÃ©es
// ========== SYSTÃˆME DE BASE DE DONNÃ‰ES SIMPLIFIÃ‰ ==========
// Sauvegarde uniquement : score, email, surnom
const DB_KEY = 'doveGameScores';

// Structure simplifiÃ©e pour la base de donnÃ©es
let playerProfile = {
  nickname: '',
  email: '',
  bestScore: 0,
  highestLevel: 1,
  lastPlayed: null
};

// Charger le profil depuis localStorage
function loadPlayerProfile() {
  try {
    const saved = localStorage.getItem(DB_KEY);
    if (saved) {
      playerProfile = JSON.parse(saved);
          return true;
    }
  } catch (error) {
    }
  return false;
}

// Sauvegarder le profil dans localStorage
function savePlayerProfile() {
  try {
    playerProfile.lastPlayed = new Date().toISOString();
    localStorage.setItem(DB_KEY, JSON.stringify(playerProfile));
      return true;
  } catch (error) {
      return false;
  }
}

// Mettre Ã  jour le score si meilleur
function updateBestScore(newScore) {
  if (newScore > playerProfile.bestScore) {
    playerProfile.bestScore = newScore;
    savePlayerProfile();
    return true; // Nouveau record !
  }
  return false;
}

// Mettre Ã  jour le niveau maximum atteint
function updateHighestLevel(newLevel) {
  if (newLevel > playerProfile.highestLevel) {
    playerProfile.highestLevel = newLevel;
    savePlayerProfile();
    
    // Sauvegarde automatique locale
    localStorage.setItem('doveGameData', JSON.stringify(gameData));
    
    // Sauvegarde automatique cloud (si connectÃ©)
    autoSaveToCloud();
    
      return true; // Nouveau niveau !
  }
  return false;
}

// Popup Ã©lÃ©gant pour le Game Over
function showGameOverPopup() {
  // CrÃ©er le popup
  const popup = document.createElement('div');
  popup.id = 'gameOverPopup';
  popup.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.8);
    background: linear-gradient(145deg, #ffffff 0%, #f5f7fa 100%);
    color: #2c3e50;
    padding: 50px 40px;
    border-radius: 30px;
    box-shadow: 
      0 25px 70px rgba(0,0,0,0.15),
      inset 0 1px 0 rgba(255,255,255,0.9),
      0 0 0 1px rgba(192,192,192,0.2);
    z-index: 10000;
    text-align: center;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    max-width: 420px;
    min-width: 340px;
    border: 2px solid rgba(192,192,192,0.3);
    animation: popupEnter 0.4s ease-out forwards;
    position: relative;
  `;

  const needsInfo = !playerProfile.nickname;

  popup.innerHTML = `
    <!-- Bordures argentÃ©es fines style bouclier -->
    <div style="
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 30px;
      pointer-events: none;
      background: 
        linear-gradient(to right, rgba(192,192,192,0.4) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(192,192,192,0.4) 1px, transparent 1px);
      background-size: 20px 20px;
    "></div>
    
    <!-- Coins dÃ©coration argentÃ©e -->
    <div style="position: absolute; top: 15px; left: 15px; width: 30px; height: 30px; border-top: 2px solid #c0c0c0; border-left: 2px solid #c0c0c0; border-radius: 8px 0 0 0;"></div>
    <div style="position: absolute; top: 15px; right: 15px; width: 30px; height: 30px; border-top: 2px solid #c0c0c0; border-right: 2px solid #c0c0c0; border-radius: 0 8px 0 0;"></div>
    <div style="position: absolute; bottom: 15px; left: 15px; width: 30px; height: 30px; border-bottom: 2px solid #c0c0c0; border-left: 2px solid #c0c0c0; border-radius: 0 0 0 8px;"></div>
    <div style="position: absolute; bottom: 15px; right: 15px; width: 30px; height: 30px; border-bottom: 2px solid #c0c0c0; border-right: 2px solid #c0c0c0; border-radius: 0 0 8px 0;"></div>

    <div style="font-size: 70px; margin-bottom: 15px; animation: shake 0.5s; position: relative; z-index: 1;">ğŸ’”</div>

    <div style="
      background: linear-gradient(145deg, rgba(192,192,192,0.08), rgba(169,169,169,0.05));
      padding: 25px;
      border-radius: 20px;
      margin-bottom: 25px;
      border: 1px solid rgba(192,192,192,0.2);
      position: relative;
      z-index: 1;
    ">
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 15px;">
        <div style="
          background: rgba(255,255,255,0.5);
          padding: 15px;
          border-radius: 12px;
          border: 1px solid rgba(192,192,192,0.2);
        ">
          <div style="font-size: 28px; font-weight: bold;">ğŸ†</div>
          <div style="font-size: 24px; font-weight: 700; margin-top: 8px; color: #667eea;">${totalScore}</div>
        </div>
        <div style="
          background: rgba(255,255,255,0.5);
          padding: 15px;
          border-radius: 12px;
          border: 1px solid rgba(192,192,192,0.2);
        ">
          <div style="font-size: 28px; font-weight: bold;">ğŸ“Š</div>
          <div style="font-size: 24px; font-weight: 700; margin-top: 8px; color: #667eea;">${level}</div>
        </div>
      </div>
      <div style="
        background: rgba(255,255,255,0.5);
        padding: 15px;
        border-radius: 12px;
        border: 1px solid rgba(192,192,192,0.2);
      ">
        <div style="font-size: 28px; font-weight: bold;">â˜ï¸</div>
        <div style="font-size: 24px; font-weight: 700; margin-top: 8px; color: #667eea;">${gameData.totalCloudsDestroyed}</div>
      </div>
    </div>

    ${needsInfo ? `
      <div style="margin-bottom: 20px; text-align: center; position: relative; z-index: 1;">
        <div style="position: relative; margin-bottom: 15px;">
          <span style="position: absolute; left: 12px; top: 50%; transform: translateY(-50%); font-size: 20px;">ğŸ®</span>
          <input id="nicknameInput" type="text" placeholder="${t('profile.enter_nickname') || 'Enter your nickname...'}"
            style="width: 100%; padding: 12px 12px 12px 45px; border: 1px solid rgba(192,192,192,0.3); border-radius: 10px; font-size: 16px;
                   background: rgba(255,255,255,0.9); color: #2c3e50; box-sizing: border-box;" />
        </div>

        <div style="position: relative;">
          <span style="position: absolute; left: 12px; top: 50%; transform: translateY(-50%); font-size: 20px;">ğŸ“§</span>
          <input id="emailInput" type="email" placeholder="${t('profile.enter_email') || 'your@email.com'}"
            style="width: 100%; padding: 12px 12px 12px 45px; border: 1px solid rgba(192,192,192,0.3); border-radius: 10px; font-size: 16px;
                   background: rgba(255,255,255,0.7); color: #2c3e50; box-sizing: border-box;" />
        </div>
      </div>
    ` : ''}

    <button id="restartBtn" style="
      width: 100%;
      padding: 20px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      border: 1px solid rgba(192,192,192,0.3);
      border-radius: 15px;
      color: white;
      font-size: 40px;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(102,126,234,0.3);
      position: relative;
      z-index: 1;
    " onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 6px 20px rgba(102,126,234,0.4)'"
       onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(102,126,234,0.3)'">
      ğŸ”„
    </button>
  `;

  // Ajouter l'animation shake
  if (!document.getElementById('shakeAnimation')) {
    const style = document.createElement('style');
    style.id = 'shakeAnimation';
    style.textContent = `
      @keyframes shake {
        0%, 100% { transform: rotate(0deg); }
        25% { transform: rotate(-10deg); }
        75% { transform: rotate(10deg); }
      }
    `;
    document.head.appendChild(style);
  }

  document.getElementById('gameContainer').appendChild(popup);

  // Gestion du bouton restart
  document.getElementById('restartBtn').addEventListener('click', () => {
    if (needsInfo) {
      const nickname = document.getElementById('nicknameInput').value.trim() || 'Anonyme';
      const email = document.getElementById('emailInput').value.trim() || '';

      playerProfile.nickname = nickname;
      playerProfile.email = email;
      savePlayerProfile();
    }

    popup.remove();
    restart();
  });

  // Focus sur le champ pseudo si nÃ©cessaire
  if (needsInfo) {
    setTimeout(() => {
      const input = document.getElementById('nicknameInput');
      if (input) input.focus();
    }, 100);
  }
}

// Demander les informations du joueur au Game Over (DÃ‰PRÃ‰CIÃ‰ - utilise showGameOverPopup)
function promptPlayerInfo() {
  showGameOverPopup();
}

// Exporter le profil pour la base de donnÃ©es
// Afficher les conseils de vie dans les onglets
function showLifeTip(category) {
  if (typeof t !== 'function') return;
  
  const categoryKey = `life_tips.${category}`;
  const contentDiv = document.getElementById('lifeTipContent');
  
  if (contentDiv) {
    const title = t(`${categoryKey}.title`);
    const tips = [
      t(`${categoryKey}.tip1`),
      t(`${categoryKey}.tip2`),
      t(`${categoryKey}.tip3`),
      t(`${categoryKey}.tip4`),
      t(`${categoryKey}.tip5`)
    ];
    
    contentDiv.innerHTML = `
      <h4 style="margin-top:0;text-align:center;color:#fff;font-size:16px;margin-bottom:15px;">${title}</h4>
      <div style="text-align:left;">
        ${tips.map(tip => `<p style="margin:10px 0;font-size:13px;line-height:1.6;">${tip}</p>`).join('')}
      </div>
    `;
  }
}

// Charger le profil au dÃ©marrage
loadPlayerProfile();

// ========== ANCIEN SYSTÃˆME (GARDÃ‰ POUR COMPATIBILITÃ‰) ==========
function saveGameData() {
  try {
    gameData.lastPlayed = new Date().toISOString();
    // Sauvegarder le stock d'Ã©toiles actuel
    gameData.starStock = starCount;
    localStorage.setItem(SAVE_KEY, JSON.stringify(gameData));
    return true;
  } catch (error) {
      return false;
  }
}

// Mettre Ã  jour les statistiques en temps rÃ©el
function updateStats(statName, value = 1) {
  if (gameData.stats.hasOwnProperty(statName)) {
    gameData.stats[statName] += value;
  }
}

// Sauvegarder la progression du niveau
function saveProgress(level, score, totalClouds) {
  let newRecord = false;
  
  // Mise Ã  jour du meilleur niveau atteint
  if (level > gameData.highestLevelReached) {
    gameData.highestLevelReached = level;
    newRecord = true;
  }
  
  // Mise Ã  jour du meilleur score
  if (score > gameData.highScore) {
    gameData.highScore = score;
    newRecord = true;
  }
  
  // Les nuages sont maintenant mis Ã  jour en temps rÃ©el dans la collision
  // Plus besoin de calculer le delta ici
  
  // Sauvegarder le stock d'Ã©toiles
  gameData.starStock = starCount;
  
  // DerniÃ¨re session
  gameData.lastScore = score;
  gameData.lastLevel = level;
  
  // Sauvegarder localement tous les 100 nuages
  if (gameData.totalCloudsDestroyed % 100 === 0) {
    saveGameData();
  } else {
    saveGameData();
  }
  
  // Sauvegarde cloud tous les 200 nuages si nouveau record
  if (newRecord && gameData.totalCloudsDestroyed % 200 === 0) {
    const nickname = localStorage.getItem('dovePlayerNickname');
    const email = localStorage.getItem('dovePlayerEmail');
    
    if (nickname && email) {
          setTimeout(() => {
        autoSaveToCloud();
      }, 1000);
    }
  }
}

// Sauvegarder Ã  la fin de la partie
function saveGameEnd(finalScore, finalLevel, finalClouds, survivalTime) {
  gameData.totalGamesPlayed++;
  gameData.totalPlayTime += Math.floor(survivalTime / 1000);
  
  if (survivalTime > gameData.stats.longestSurvival) {
    gameData.stats.longestSurvival = survivalTime;
  }
  
  saveProgress(finalLevel, finalScore, finalClouds);
}

// RÃ©initialiser toutes les donnÃ©es (pour debug ou reset complet)
function resetGameData() {
  if (confirm(t('popups.reset_confirm'))) {
    localStorage.removeItem(SAVE_KEY);
    gameData = {
      highestLevelReached: 1,
      highScore: 0,
      totalCloudsDestroyed: 0,
      totalGamesPlayed: 0,
      totalPlayTime: 0,
      stats: {
        totalShots: 0,
        totalHits: 0,
        totalMisses: 0,
        totalPowerUpsCollected: 0,
        totalLivesLost: 0,
        longestSurvival: 0,
        perfectLevels: 0,
        deathsByClouds: 0,
        deathsByRain: 0
      },
      achievements: [],
      bonusLevels: {
        completed: [false, false, false, false],
        bestScores: [0, 0, 0, 0],
        totalItemsCollected: 0
      },
      lastPlayed: null,
      lastScore: 0,
      lastLevel: 1
    };
      return true;
  }
  return false;
}

// Exporter les donnÃ©es (pour backup)
function exportGameData() {
  // CrÃ©er un canvas pour l'image
  const canvas = document.createElement('canvas');
  canvas.width = 1080;
  canvas.height = 1080;
  const ctx = canvas.getContext('2d');
  
  // Fond dÃ©gradÃ© bleu ciel
  const gradient = ctx.createLinearGradient(0, 0, 0, 1080);
  gradient.addColorStop(0, '#87ceeb');
  gradient.addColorStop(0.5, '#b8d8f8');
  gradient.addColorStop(1, '#e3f2fd');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, 1080, 1080);
  
  // Dessiner le soleil
  ctx.shadowBlur = 30;
  ctx.shadowColor = '#ffd700';
  ctx.fillStyle = '#ffd700';
  ctx.beginPath();
  ctx.arc(900, 200, 70, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  
  // Rayons du soleil
  ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
  ctx.lineWidth = 3;
  for (let i = 0; i < 12; i++) {
    const angle = (i * 30) * Math.PI / 180;
    ctx.beginPath();
    ctx.moveTo(900 + Math.cos(angle) * 80, 200 + Math.sin(angle) * 80);
    ctx.lineTo(900 + Math.cos(angle) * 120, 200 + Math.sin(angle) * 120);
    ctx.stroke();
  }
  
  // Petits nuages blancs
  const drawCloud = (x, y, size) => {
    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.beginPath();
    ctx.arc(x, y, size, 0, Math.PI * 2);
    ctx.arc(x + size * 0.8, y - size * 0.3, size * 0.8, 0, Math.PI * 2);
    ctx.arc(x + size * 1.6, y, size * 0.9, 0, Math.PI * 2);
    ctx.arc(x + size * 2.2, y + size * 0.2, size * 0.7, 0, Math.PI * 2);
    ctx.fill();
  };
  
  drawCloud(150, 250, 25);
  drawCloud(800, 320, 30);
  drawCloud(300, 500, 20);
  drawCloud(950, 550, 28);
  drawCloud(100, 600, 22);
  
  // Particules bonus flottantes
  // Ã‰toile
  const drawStar = (x, y, size) => {
    ctx.fillStyle = '#f39c12';
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#f39c12';
    ctx.beginPath();
    for (let i = 0; i < 5; i++) {
      const angle1 = (i * 72 - 90) * Math.PI / 180;
      const angle2 = ((i * 72) + 36 - 90) * Math.PI / 180;
      if (i === 0) ctx.moveTo(x + Math.cos(angle1) * size, y + Math.sin(angle1) * size);
      else ctx.lineTo(x + Math.cos(angle1) * size, y + Math.sin(angle1) * size);
      ctx.lineTo(x + Math.cos(angle2) * size * 0.5, y + Math.sin(angle2) * size * 0.5);
    }
    ctx.closePath();
    ctx.fill();
    ctx.shadowBlur = 0;
  };
  
  // CÅ“ur
  const drawHeart = (x, y, size) => {
    ctx.fillStyle = '#e74c3c';
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#e74c3c';
    ctx.beginPath();
    ctx.moveTo(x, y + size * 0.3);
    ctx.bezierCurveTo(x, y, x - size * 0.5, y - size * 0.3, x - size * 0.5, y + size * 0.1);
    ctx.bezierCurveTo(x - size * 0.5, y + size * 0.5, x, y + size * 0.7, x, y + size);
    ctx.bezierCurveTo(x, y + size * 0.7, x + size * 0.5, y + size * 0.5, x + size * 0.5, y + size * 0.1);
    ctx.bezierCurveTo(x + size * 0.5, y - size * 0.3, x, y, x, y + size * 0.3);
    ctx.fill();
    ctx.shadowBlur = 0;
  };
  
  // Croix
  const drawCross = (x, y, size) => {
    ctx.strokeStyle = '#3498db';
    ctx.lineWidth = size * 0.3;
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#3498db';
    ctx.beginPath();
    ctx.moveTo(x, y - size);
    ctx.lineTo(x, y + size);
    ctx.moveTo(x - size * 0.7, y);
    ctx.lineTo(x + size * 0.7, y);
    ctx.stroke();
    ctx.shadowBlur = 0;
  };
  
  // Arc-en-ciel
  const drawRainbow = (x, y, size) => {
    const colors = ['#e74c3c', '#f39c12', '#f1c40f', '#2ecc71', '#3498db', '#9b59b6'];
    ctx.lineWidth = size * 0.15;
    for (let i = 0; i < colors.length; i++) {
      ctx.strokeStyle = colors[i];
      ctx.beginPath();
      ctx.arc(x, y + size * 0.8, size - i * (size * 0.15), Math.PI, 0);
      ctx.stroke();
    }
  };
  
  // Disposer les particules
  drawStar(200, 400, 20);
  drawHeart(850, 450, 25);
  drawCross(100, 350, 18);
  drawRainbow(950, 680, 35);
  drawStar(750, 600, 15);
  drawHeart(300, 650, 20);
  
  // Dessiner les montagnes en bas
  // Montagne arriÃ¨re gauche
  ctx.fillStyle = '#b8c5d0';
  ctx.beginPath();
  ctx.moveTo(0, 1080);
  ctx.lineTo(200, 850);
  ctx.lineTo(400, 1080);
  ctx.closePath();
  ctx.fill();
  
  // Montagne arriÃ¨re droite
  ctx.fillStyle = '#b8c5d0';
  ctx.beginPath();
  ctx.moveTo(680, 1080);
  ctx.lineTo(880, 850);
  ctx.lineTo(1080, 1080);
  ctx.closePath();
  ctx.fill();
  
  // Montagne centrale (la plus haute et plus mince)
  ctx.fillStyle = '#e8ecf0';
  ctx.beginPath();
  ctx.moveTo(420, 1080);
  ctx.lineTo(540, 800);
  ctx.lineTo(660, 1080);
  ctx.closePath();
  ctx.fill();
  
  // Sommet neigeux central (plus petit)
  ctx.fillStyle = '#ffffff';
  ctx.beginPath();
  ctx.moveTo(520, 860);
  ctx.lineTo(540, 800);
  ctx.lineTo(560, 860);
  ctx.closePath();
  ctx.fill();
  
  // Montagne avant gauche
  ctx.fillStyle = '#d0dae3';
  ctx.beginPath();
  ctx.moveTo(0, 1080);
  ctx.lineTo(150, 900);
  ctx.lineTo(350, 1080);
  ctx.closePath();
  ctx.fill();
  
  // Montagne avant droite
  ctx.fillStyle = '#d0dae3';
  ctx.beginPath();
  ctx.moveTo(730, 1080);
  ctx.lineTo(930, 900);
  ctx.lineTo(1080, 1080);
  ctx.closePath();
  ctx.fill();
  
  // Dessiner la colombe (style du jeu)
  const birdX = 440;
  const birdY = 300;
  const scale = 4;
  
  // Corps de l'oiseau (sans halo jaune)
  ctx.shadowBlur = 0;
  ctx.fillStyle = '#ffffff';
  ctx.strokeStyle = '#2c3e50';
  ctx.lineWidth = 3;
  
  // TÃªte
  ctx.beginPath();
  ctx.moveTo(birdX + 20*scale, birdY + 8*scale);
  ctx.lineTo(birdX + 15*scale, birdY + 22*scale);
  ctx.lineTo(birdX + 25*scale, birdY + 22*scale);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  
  // Aile gauche
  ctx.beginPath();
  ctx.moveTo(birdX + 15*scale, birdY + 12*scale);
  ctx.lineTo(birdX + 2*scale, birdY + 8*scale);
  ctx.lineTo(birdX + 18*scale, birdY + 25*scale);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  
  // Aile droite
  ctx.beginPath();
  ctx.moveTo(birdX + 25*scale, birdY + 12*scale);
  ctx.lineTo(birdX + 38*scale, birdY + 8*scale);
  ctx.lineTo(birdX + 22*scale, birdY + 25*scale);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  
  // Queue
  ctx.beginPath();
  ctx.moveTo(birdX + 20*scale, birdY + 22*scale);
  ctx.lineTo(birdX + 18*scale, birdY + 30*scale);
  ctx.lineTo(birdX + 22*scale, birdY + 30*scale);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  
  ctx.shadowBlur = 0;
  
  // Titre du jeu
  ctx.fillStyle = '#2c3e50';
  ctx.font = 'bold 60px Arial';
  ctx.textAlign = 'center';
  ctx.fillText('Dove of Hope', 540, 150);
  ctx.font = '36px Arial';
  ctx.fillText('Sky Blessing', 540, 200);
  
  // Score
  ctx.fillStyle = '#f39c12';
  ctx.font = 'bold 80px Arial';
  ctx.fillText(`${t('export.score_label')}: ${gameData.highScore.toLocaleString()}`, 540, 540);
  
  // Niveau
  ctx.fillStyle = '#3498db';
  ctx.font = 'bold 50px Arial';
  ctx.fillText(`${t('export.level_label')} ${gameData.highestLevelReached}`, 540, 620);
  
  // Nuages dÃ©truits
  ctx.fillStyle = '#95a5a6';
  ctx.font = '40px Arial';
  ctx.fillText(t('clouds_cleared', {count: gameData.totalCloudsDestroyed}), 540, 680);
  
  // Message motivant
  ctx.fillStyle = '#e74c3c';
  ctx.font = 'bold italic 45px Arial';
  ctx.textAlign = 'center';
  ctx.fillText(t('export.courage_message'), 540, 770);
  
  // Phrase inspirante
  ctx.fillStyle = '#2c3e50';
  ctx.font = '32px Arial';
  ctx.fillText(t('transform_clouds'), 540, 830);
  ctx.fillText(t('export.divine_light'), 540, 870);
  
  // TÃ©lÃ©charger l'image en JPG
  canvas.toBlob((blob) => {
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `dove-of-hope-score-${gameData.highScore}.jpg`;
    link.click();
    URL.revokeObjectURL(url);
    }, 'image/jpeg', 0.95);
}

// Importer les donnÃ©es (pour restore)
function importGameData(fileInput) {
  const file = fileInput.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const imported = JSON.parse(e.target.result);
        gameData = { ...gameData, ...imported };
        saveGameData();
              showPopup(t('popups.data_imported'), 'ğŸ’¾', 'success');
      } catch (error) {
              showPopup(t('popups.invalid_file'), 'âš ï¸', 'error');
      }
    };
    reader.readAsText(file);
  }
}

// ============================================
// ï¿½ SYSTÃˆME AUDIO
// ============================================
const audioContext = new (window.AudioContext || window.webkitAudioContext)();
let audioInitialized = false;
let musicEnabled = true;
let sfxEnabled = true;

// Fonction pour initialiser l'AudioContext aprÃ¨s interaction utilisateur
function initAudioContext() {
  if (!audioInitialized) {
    audioInitialized = true;
    }
}

// Playlist de musiques gospel
const gospelPlaylist = [
  'public/gospel/je-te-donne-ma-vie.mp3', // Toujours en premier
  'public/gospel/reflet-trompeurs.mp3', // DeuxiÃ¨me chanson
  'public/gospel/chacun-sa-place-sous-le-ciel-de-papa.mp3',
  'public/gospel/cours-vers-ta-destinee.mp3',
  'public/gospel/dans-quel-monde-on-vit.mp3',
  'public/gospel/elle-ma-dit-il-est-vivant.mp3',
  'public/gospel/esperance.mp3',
  'public/gospel/il-est-la-la-avec-nous.mp3',
  'public/gospel/il-y-a-un-espoir-pour-toi-pour-moi.mp3',
  'public/gospel/il-y-a-une-chose-que-tu-dois-voir.mp3',
  'public/gospel/Je-tecoute-parler-mais-tout-mechappe.mp3',
  'public/gospel/je-veux-prier.mp3',
  'public/gospel/jesus-connait-ta-vie.mp3',
  'public/gospel/jai-un-secret-en-moi.mp3',
  'public/gospel/la-paix-renait-toujours.mp3',
  'public/gospel/la-parole-est-venue.mp3',
  'public/gospel/le-torrent-de-larnon.mp3',
  'public/gospel/les-anges-sont-descendus-vers-toi.mp3',
  'public/gospel/mise-a-jour-de-mon-coeur.mp3',
  'public/gospel/nabandonne-jamais.mp3',
  'public/gospel/nabandonne-pas.mp3',
  'public/gospel/prends-le-chemin.mp3',
  'public/gospel/priez-pour-resister-au-mal.mp3',
  'public/gospel/quand-tout-semblait-sombrer.mp3',
  'public/gospel/que-je-vive.mp3',
  'public/gospel/tiens-bon-tiens-bon.mp3',
  'public/gospel/tu-es-appele-a-porte-la-paix.mp3',
  'public/gospel/tu-mas-tendue-la-main.mp3'
  // 'public/gospel/un-sos-sur-les-flots.mp3' - RÃ‰SERVÃ‰ au boss Dark Cloud uniquement
];

let currentTrackIndex = 0;
let musicAudio = null;
let firstPlay = true; // Pour savoir si c'est le premier lancement
let rainMusicAudio = null; // Audio spÃ©cial pour la pluie
let normalMusicPaused = false; // Pour reprendre la musique normale aprÃ¨s la pluie
const rainMusicPath = 'public/gospel/un-sos-sur-les-flots.mp3'; // Chanson pour la pluie

// Fonction pour jouer une musique alÃ©atoire
function playRandomMusic() {
  if (!musicEnabled || normalMusicPaused) return;
  
  // Initialiser l'AudioContext si ce n'est pas dÃ©jÃ  fait
  if (!audioInitialized) {
    initAudioContext();
  }
  
  // Si c'est le premier lancement, commencer par "Je te donne ma vie"
  if (firstPlay) {
    currentTrackIndex = 0; // Index 0 = "Je te donne ma vie"
    firstPlay = false;
  } else {
    // Ensuite, jouer alÃ©atoirement
    currentTrackIndex = Math.floor(Math.random() * gospelPlaylist.length);
  }
  
  // CrÃ©er un nouvel Ã©lÃ©ment audio
  if (musicAudio) {
    musicAudio.pause();
    musicAudio = null;
  }
  
  musicAudio = new Audio(gospelPlaylist[currentTrackIndex]);
  musicAudio.volume = 0.3; // Volume modÃ©rÃ©
  
  // Gestion d'erreur amÃ©liorÃ©e pour fichiers manquants
  musicAudio.addEventListener('error', (e) => {
      // Passer Ã  la chanson suivante
    playRandomMusic();
  });
  
  musicAudio.play().catch(err => {
  });
  
  // Quand la musique se termine, jouer la suivante
  musicAudio.addEventListener('ended', () => {
    playRandomMusic();
  });
}

// Fonction pour jouer la musique de pluie
function playRainMusic() {
  if (!musicEnabled) return;
  
  // Initialiser l'AudioContext si ce n'est pas dÃ©jÃ  fait
  if (!audioInitialized) {
    initAudioContext();
  }
  
  // Mettre en pause la musique normale
  if (musicAudio && !musicAudio.paused) {
    musicAudio.pause();
    normalMusicPaused = true;
  }
  
  // Si la musique de pluie joue dÃ©jÃ , ne rien faire
  if (rainMusicAudio && !rainMusicAudio.paused) return;
  
  // CrÃ©er et jouer la musique de pluie
  if (rainMusicAudio) {
    rainMusicAudio.pause();
    rainMusicAudio = null;
  }
  
  rainMusicAudio = new Audio(rainMusicPath);
  rainMusicAudio.volume = 0.35; // Un peu plus fort pour la pluie
  rainMusicAudio.loop = false; // PAS de boucle - la chanson se termine naturellement
  
  // Quand la chanson de pluie se termine, reprendre la playlist alÃ©atoire
  rainMusicAudio.addEventListener('ended', () => {
      rainMusicAudio = null;
    normalMusicPaused = false;
    if (musicEnabled) {
      playRandomMusic();
    }
  });
  
  rainMusicAudio.play().catch(err => {
    // Ignorer silencieusement les erreurs d'autoplay (restrictions navigateur)
  });
}

// Fonction pour arrÃªter la musique de pluie (utilisÃ©e seulement en cas de game over ou pause)
function stopRainMusic(resumeNormalMusic = true) {
  if (rainMusicAudio) {
    rainMusicAudio.pause();
    rainMusicAudio.currentTime = 0;
    rainMusicAudio = null;
  }
  
  // Reprendre la musique normale seulement si demandÃ©
  if (resumeNormalMusic) {
    normalMusicPaused = false;
    if (musicEnabled && musicAudio && musicAudio.paused) {
      musicAudio.play().catch(err => {
        // Ignorer silencieusement les erreurs d'autoplay (restrictions navigateur)
      });
    } else if (musicEnabled && !musicAudio) {
      playRandomMusic();
    }
  }
}

// Fonction pour arrÃªter la musique
function stopMusic() {
  if (musicAudio) {
    musicAudio.pause();
    musicAudio.currentTime = 0;
  }
  if (rainMusicAudio) {
    rainMusicAudio.pause();
    rainMusicAudio.currentTime = 0;
  }
}

// Boutons de contrÃ´le audio
const musicBtn = document.getElementById('musicBtn');
const sfxBtn = document.getElementById('sfxBtn');

musicBtn.addEventListener('click', () => {
  musicEnabled = !musicEnabled;
  musicBtn.classList.toggle('muted', !musicEnabled);
  musicBtn.textContent = musicEnabled ? 'ğŸµ' : 'ğŸ”‡';
  if (musicEnabled && state === 'playing') {
    playRandomMusic();
  } else {
    stopMusic();
  }
});

sfxBtn.addEventListener('click', () => {
  sfxEnabled = !sfxEnabled;
  sfxBtn.classList.toggle('muted', !sfxEnabled);
  sfxBtn.textContent = sfxEnabled ? 'ğŸ”Š' : 'ğŸ”‡';
});

// Fonction pour jouer un son simple avec Web Audio API
function playSound(type) {
  if (!sfxEnabled) return;
  
  const now = audioContext.currentTime;
  
  switch(type) {
    case 'shoot': // Tir - plok plouf doux
      {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        // Filtre pour adoucir le son
        const filter = audioContext.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 800;
        filter.Q.value = 1;
        
        oscillator.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        // Son de goutte : frÃ©quence qui descend rapidement
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(600, now);
        oscillator.frequency.exponentialRampToValueAtTime(200, now + 0.08);
        
        // Enveloppe douce et plus faible
        gainNode.gain.setValueAtTime(0.08, now); // RÃ©duit de 0.15 Ã  0.08
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
        
        oscillator.start(now);
        oscillator.stop(now + 0.08);
      }
      break;
      
    case 'hit': // Nuage dÃ©truit - souffle de vent plus long
      {
        const bufferSize = audioContext.sampleRate * 0.25; // 250ms
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const output = buffer.getChannelData(0);
        
        // Bruit blanc
        for (let i = 0; i < bufferSize; i++) {
          output[i] = Math.random() * 2 - 1;
        }
        
        const noise = audioContext.createBufferSource();
        noise.buffer = buffer;
        
        // Filtre passe-bande pour un son de vent doux
        const filter = audioContext.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = 800;
        filter.Q.value = 1;
        
        const gainNode = audioContext.createGain();
        gainNode.gain.setValueAtTime(0.25, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
        
        noise.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        noise.start(now);
        noise.stop(now + 0.25);
      }
      break;
      
    case 'powerup': // Power-up collectÃ©
      {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.setValueAtTime(400, now);
        oscillator.frequency.setValueAtTime(600, now + 0.05);
        oscillator.frequency.setValueAtTime(800, now + 0.1);
        gainNode.gain.setValueAtTime(0.3, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        oscillator.start(now);
        oscillator.stop(now + 0.15);
      }
      break;
      
    case 'damage': // DÃ©gÃ¢t reÃ§u
      {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.setValueAtTime(200, now);
        oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.3);
        oscillator.type = 'sawtooth';
        gainNode.gain.setValueAtTime(0.5, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        oscillator.start(now);
        oscillator.stop(now + 0.3);
      }
      break;
      
    case 'levelup': // Passage de niveau
      {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.setValueAtTime(400, now);
        oscillator.frequency.setValueAtTime(500, now + 0.1);
        oscillator.frequency.setValueAtTime(600, now + 0.2);
        oscillator.frequency.setValueAtTime(800, now + 0.3);
        gainNode.gain.setValueAtTime(0.4, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
        oscillator.start(now);
        oscillator.stop(now + 0.4);
      }
      break;
      
    case 'shockwave': // Onde de choc
      {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.setValueAtTime(100, now);
        oscillator.frequency.exponentialRampToValueAtTime(1000, now + 0.5);
        oscillator.type = 'sine';
        gainNode.gain.setValueAtTime(0.6, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
        oscillator.start(now);
        oscillator.stop(now + 0.5);
      }
      break;
      
    case 'rainbow': // Nuage touche bouclier arc-en-ciel - "batsheuu" doux et long
      {
        // CrÃ©er un buffer de bruit rose (plus doux que blanc)
        const bufferSize = audioContext.sampleRate * 0.4; // 400ms - long et relaxant
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const output = buffer.getChannelData(0);
        
        // GÃ©nÃ©rer du bruit rose filtrÃ© (plus naturel et doux)
        let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
        for (let i = 0; i < bufferSize; i++) {
          const white = Math.random() * 2 - 1;
          b0 = 0.99886 * b0 + white * 0.0555179;
          b1 = 0.99332 * b1 + white * 0.0750759;
          b2 = 0.96900 * b2 + white * 0.1538520;
          b3 = 0.86650 * b3 + white * 0.3104856;
          b4 = 0.55000 * b4 + white * 0.5329522;
          b5 = -0.7616 * b5 - white * 0.0168980;
          output[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;
          b6 = white * 0.115926;
        }
        
        const noise = audioContext.createBufferSource();
        noise.buffer = buffer;
        
        // Filtre pour un son magique et doux
        const filter = audioContext.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = 1200; // FrÃ©quence moyenne douce
        filter.Q.value = 2; // RÃ©sonance pour effet magique
        
        const gainNode = audioContext.createGain();
        gainNode.gain.setValueAtTime(0.2, now);
        gainNode.gain.linearRampToValueAtTime(0.25, now + 0.1); // Monte lÃ©gÃ¨rement
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.4); // Descend doucement
        
        noise.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        noise.start(now);
        noise.stop(now + 0.4);
      }
      break;
      
    case 'bonus': // Collecte d'objet bonus - son joyeux
      {
        // CrÃ©er deux oscillateurs pour un son riche
        const osc1 = audioContext.createOscillator();
        const osc2 = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        // Mixer les deux oscillateurs
        const merger = audioContext.createChannelMerger(2);
        osc1.connect(merger, 0, 0);
        osc2.connect(merger, 0, 1);
        merger.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        // Son brillant qui monte
        osc1.type = 'sine';
        osc2.type = 'sine';
        osc1.frequency.setValueAtTime(523, now); // Do
        osc2.frequency.setValueAtTime(659, now); // Mi
        osc1.frequency.setValueAtTime(784, now + 0.08); // Sol
        osc2.frequency.setValueAtTime(1047, now + 0.08); // Do aigu
        
        // Enveloppe joyeuse
        gainNode.gain.setValueAtTime(0.25, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        
        osc1.start(now);
        osc2.start(now);
        osc1.stop(now + 0.15);
        osc2.stop(now + 0.15);
      }
      break;
      
    case 'boss_spawn': // Apparition d'un boss - son d'horreur sinistre
      {
        // Drone bass sombre et oppressant
        const bass = audioContext.createOscillator();
        const bassGain = audioContext.createGain();
        bass.type = 'sawtooth';
        bass.frequency.setValueAtTime(40, now);
        bass.frequency.exponentialRampToValueAtTime(30, now + 2);
        bassGain.gain.setValueAtTime(0.3, now);
        bassGain.gain.exponentialRampToValueAtTime(0.01, now + 2);
        bass.connect(bassGain);
        bassGain.connect(audioContext.destination);
        bass.start(now);
        bass.stop(now + 2);
        
        // Son strident qui descend (cri d'horreur)
        const shriek = audioContext.createOscillator();
        const shriekGain = audioContext.createGain();
        shriek.type = 'square';
        shriek.frequency.setValueAtTime(1200, now + 0.2);
        shriek.frequency.exponentialRampToValueAtTime(200, now + 1.5);
        shriekGain.gain.setValueAtTime(0, now + 0.2);
        shriekGain.gain.linearRampToValueAtTime(0.2, now + 0.3);
        shriekGain.gain.exponentialRampToValueAtTime(0.01, now + 1.5);
        shriek.connect(shriekGain);
        shriekGain.connect(audioContext.destination);
        shriek.start(now + 0.2);
        shriek.stop(now + 1.5);
        
        // Bruit blanc pour ambiance d'horreur
        const bufferSize = audioContext.sampleRate * 2;
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const output = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          output[i] = (Math.random() * 2 - 1) * 0.1;
        }
        const noise = audioContext.createBufferSource();
        noise.buffer = buffer;
        const noiseGain = audioContext.createGain();
        noiseGain.gain.setValueAtTime(0.15, now);
        noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 2);
        noise.connect(noiseGain);
        noiseGain.connect(audioContext.destination);
        noise.start(now);
      }
      break;
      
    case 'thunder': // Ã‰clair / Tonnerre pour le boss Dark Cloud
      {
        // Crack initial trÃ¨s court et aigu (Ã©clair)
        const crack = audioContext.createOscillator();
        const crackGain = audioContext.createGain();
        crack.type = 'square';
        crack.frequency.setValueAtTime(2000, now);
        crack.frequency.exponentialRampToValueAtTime(100, now + 0.05);
        crackGain.gain.setValueAtTime(0.4, now);
        crackGain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
        crack.connect(crackGain);
        crackGain.connect(audioContext.destination);
        crack.start(now);
        crack.stop(now + 0.05);
        
        // Grondement du tonnerre (bass qui roule)
        const rumble = audioContext.createOscillator();
        const rumbleGain = audioContext.createGain();
        rumble.type = 'sawtooth';
        rumble.frequency.setValueAtTime(60, now + 0.05);
        rumble.frequency.exponentialRampToValueAtTime(30, now + 1.2);
        rumbleGain.gain.setValueAtTime(0, now + 0.05);
        rumbleGain.gain.linearRampToValueAtTime(0.35, now + 0.15);
        rumbleGain.gain.exponentialRampToValueAtTime(0.01, now + 1.2);
        rumble.connect(rumbleGain);
        rumbleGain.connect(audioContext.destination);
        rumble.start(now + 0.05);
        rumble.stop(now + 1.2);
        
        // Bruit blanc pour le grondement
        const bufferSize = audioContext.sampleRate * 1.2;
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const output = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          output[i] = (Math.random() * 2 - 1) * 0.2 * (1 - i / bufferSize);
        }
        const noise = audioContext.createBufferSource();
        noise.buffer = buffer;
        const noiseFilter = audioContext.createBiquadFilter();
        noiseFilter.type = 'lowpass';
        noiseFilter.frequency.value = 200;
        const noiseGain = audioContext.createGain();
        noiseGain.gain.setValueAtTime(0.3, now + 0.05);
        noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 1.2);
        noise.connect(noiseFilter);
        noiseFilter.connect(noiseGain);
        noiseGain.connect(audioContext.destination);
        noise.start(now + 0.05);
      }
      break;
      
    case 'chicken_cluck': // CaquÃ¨tement de la poule (cotcot kaket)
      {
        // Son aigu et rapide qui monte et descend (cot-cot-cot-kaket)
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        
        osc.type = 'square';
        osc.connect(gain);
        gain.connect(audioContext.destination);
        
        // Premier "cot" (court et aigu)
        osc.frequency.setValueAtTime(800, now);
        gain.gain.setValueAtTime(0.15, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
        
        // DeuxiÃ¨me "cot" 
        osc.frequency.setValueAtTime(850, now + 0.12);
        gain.gain.setValueAtTime(0.15, now + 0.12);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.20);
        
        // "kaket" final (un peu plus long et descendant)
        osc.frequency.setValueAtTime(900, now + 0.28);
        osc.frequency.exponentialRampToValueAtTime(650, now + 0.45);
        gain.gain.setValueAtTime(0.18, now + 0.28);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.45);
        
        osc.start(now);
        osc.stop(now + 0.45);
      }
      break;
      
    case 'egg_drop': // Å’uf qui tombe (shouuup!)
      {
        // Son qui descend rapidement (whoosh descendant)
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        
        osc.type = 'sine';
        osc.connect(gain);
        gain.connect(audioContext.destination);
        
        // Descente rapide de frÃ©quence (shouuup!)
        osc.frequency.setValueAtTime(1200, now);
        osc.frequency.exponentialRampToValueAtTime(200, now + 0.4);
        
        gain.gain.setValueAtTime(0.25, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
        
        osc.start(now);
        osc.stop(now + 0.4);
        
        // Ajouter un bruit blanc court pour le "sh"
        const bufferSize = audioContext.sampleRate * 0.15;
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const output = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          output[i] = (Math.random() * 2 - 1) * 0.3 * (1 - i / bufferSize);
        }
        const noise = audioContext.createBufferSource();
        noise.buffer = buffer;
        const noiseFilter = audioContext.createBiquadFilter();
        noiseFilter.type = 'highpass';
        noiseFilter.frequency.value = 2000;
        const noiseGain = audioContext.createGain();
        noiseGain.gain.setValueAtTime(0.2, now);
        noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        noise.connect(noiseFilter);
        noiseFilter.connect(noiseGain);
        noiseGain.connect(audioContext.destination);
        noise.start(now);
      }
      break;
      
    case 'chicken_walk': // Plouplou - dÃ©placement de la poule
      {
        // Premier "plou" (montant, lÃ©ger)
        const osc1 = audioContext.createOscillator();
        const gain1 = audioContext.createGain();
        
        osc1.type = 'sine';
        osc1.frequency.setValueAtTime(400, now);
        osc1.frequency.exponentialRampToValueAtTime(550, now + 0.08);
        gain1.gain.setValueAtTime(0.12, now);
        gain1.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
        
        osc1.connect(gain1);
        gain1.connect(audioContext.destination);
        osc1.start(now);
        osc1.stop(now + 0.08);
        
        // DeuxiÃ¨me "plou" (montant, un peu plus aigu)
        const osc2 = audioContext.createOscillator();
        const gain2 = audioContext.createGain();
        
        osc2.type = 'sine';
        osc2.frequency.setValueAtTime(500, now + 0.1);
        osc2.frequency.exponentialRampToValueAtTime(650, now + 0.18);
        gain2.gain.setValueAtTime(0.12, now + 0.1);
        gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.18);
        
        osc2.connect(gain2);
        gain2.connect(audioContext.destination);
        osc2.start(now + 0.1);
        osc2.stop(now + 0.18);
      }
      break;
      
    case 'snake_hiss': // Sifflement rÃ©aliste de serpent Ã  sonnette
      {
        // CrÃ©er un son de crÃ©celle caractÃ©ristique du serpent Ã  sonnette
        const duration = 0.8;
        const bufferSize = audioContext.sampleRate * duration;
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        
        // GÃ©nÃ©rer un son de crÃ©celle rapide (60-100 Hz de tremblement)
        for (let i = 0; i < bufferSize; i++) {
          const t = i / audioContext.sampleRate;
          // FrÃ©quence de base basse (serpent gros)
          const baseFreq = 80 + Math.sin(t * 10) * 20;
          // Modulation rapide pour effet crÃ©celle
          const rattle = Math.sin(t * Math.PI * 2 * 90) * 0.5;
          // Bruit pour texture rÃ©aliste
          const noise = (Math.random() * 2 - 1) * 0.3;
          // Combinaison avec enveloppe
          const envelope = Math.sin(t / duration * Math.PI) * 0.8;
          data[i] = (Math.sin(t * Math.PI * 2 * baseFreq) * 0.4 + rattle + noise) * envelope;
        }
        
        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        
        // Filtre pour donner un son plus naturel
        const filter = audioContext.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = 3000;
        filter.Q.value = 2;
        
        const gain = audioContext.createGain();
        gain.gain.setValueAtTime(0.35, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + duration);
        
        source.connect(filter);
        filter.connect(gain);
        gain.connect(audioContext.destination);
        source.start(now);
      }
      break;
      
    case 'snake_flip': // Frottement gras du serpent "croh greee"
      {
        const duration = 0.45;
        const bufferSize = audioContext.sampleRate * duration;
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        
        // Son de frottement gras et rugueux "croh greee"
        for (let i = 0; i < bufferSize; i++) {
          const t = i / audioContext.sampleRate;
          // Bruit trÃ¨s gras et dominant
          const noise = (Math.random() * 2 - 1);
          // FrÃ©quence basse pour son gras "croh"
          const freq = 120 - t * 40;
          const rumble = Math.sin(t * Math.PI * 2 * freq);
          // Grondement grave pour texture Ã©paisse
          const lowGrowl = Math.sin(t * Math.PI * 2 * 60) * 0.6;
          // Modulation lente pour effet rugueux "greee"
          const grind = Math.sin(t * 80 * Math.PI) * 0.5;
          // Crachotement pour texture
          const crackle = (Math.random() > 0.7 ? Math.random() * 0.4 : 0);
          const envelope = 1 - Math.pow(t / duration, 2);
          data[i] = (noise * 0.6 + rumble * 0.8 + lowGrowl + grind + crackle) * envelope;
        }
        
        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        
        // Filtre pour son gras (frÃ©quences basses-moyennes)
        const filter = audioContext.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 450; // Plus bas pour son plus gras
        filter.Q.value = 2;
        
        const gain = audioContext.createGain();
        gain.gain.value = 0.45; // Volume encore plus fort
        
        source.connect(filter);
        filter.connect(gain);
        gain.connect(audioContext.destination);
        source.start(now);
      }
      break;
      
    case 'snake_spit': // Attaque agressive avec sifflement
      {
        // Sifflement agressif court
        const duration = 0.25;
        const bufferSize = audioContext.sampleRate * duration;
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
          const t = i / audioContext.sampleRate;
          // Sifflement aigu descendant
          const freq = 8000 - t * 6000;
          const hiss = Math.sin(t * Math.PI * 2 * freq);
          // Bruit pour effet "crachat"
          const noise = (Math.random() * 2 - 1) * 0.7;
          const envelope = Math.exp(-t * 12);
          data[i] = (hiss * 0.3 + noise * 0.7) * envelope;
        }
        
        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        
        const filter = audioContext.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 2000;
        
        const gain = audioContext.createGain();
        gain.gain.value = 0.28;
        
        source.connect(filter);
        filter.connect(gain);
        gain.connect(audioContext.destination);
        source.start(now);
      }
      break;
      
    case 'wall_break': // Pierre qui se brise
      {
        // Impact initial fort
        const impact = audioContext.createOscillator();
        const impactGain = audioContext.createGain();
        impact.type = 'triangle';
        impact.frequency.setValueAtTime(120, now);
        impact.frequency.exponentialRampToValueAtTime(40, now + 0.15);
        impactGain.gain.setValueAtTime(0.4, now);
        impactGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        impact.connect(impactGain);
        impactGain.connect(audioContext.destination);
        impact.start(now);
        impact.stop(now + 0.15);
        
        // Bruit de dÃ©bris/gravats
        const bufferSize = audioContext.sampleRate * 0.6;
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
          const t = i / audioContext.sampleRate;
          // Bruit granuleux pour les dÃ©bris
          const debris = (Math.random() * 2 - 1);
          // Craquements
          const crack = (Math.random() > 0.85 ? Math.random() * 0.5 : 0);
          const envelope = Math.exp(-t * 4);
          data[i] = (debris * 0.7 + crack) * envelope;
        }
        
        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        const filter = audioContext.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = 800;
        filter.Q.value = 1;
        const gain = audioContext.createGain();
        gain.gain.value = 0.3;
        source.connect(filter);
        filter.connect(gain);
        gain.connect(audioContext.destination);
        source.start(now);
      }
      break;
      
    case 'wall_chain': // ChaÃ®nes qui tombent
      {
        const duration = 0.8;
        const bufferSize = audioContext.sampleRate * duration;
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
          const t = i / audioContext.sampleRate;
          // Son mÃ©tallique des maillons
          const metalFreq = 800 + Math.sin(t * 40) * 200;
          const metal = Math.sin(t * Math.PI * 2 * metalFreq) * 0.3;
          // Cliquetis des chaÃ®nes
          const rattle = (Math.random() > 0.6 ? Math.random() * 0.4 : 0);
          // Descente pour chute
          const fall = Math.sin(t * Math.PI * 2 * (500 - t * 200)) * 0.2;
          const envelope = 1 - Math.pow(t / duration, 1.5);
          data[i] = (metal + rattle + fall) * envelope;
        }
        
        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        const filter = audioContext.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 400;
        const gain = audioContext.createGain();
        gain.gain.value = 0.25;
        source.connect(filter);
        filter.connect(gain);
        gain.connect(audioContext.destination);
        source.start(now);
      }
      break;
      
    case 'wall_rumble': // Tremblement du mur
      {
        // Grondement sourd
        const rumble = audioContext.createOscillator();
        const rumbleGain = audioContext.createGain();
        rumble.type = 'sawtooth';
        rumble.frequency.setValueAtTime(50, now);
        rumble.frequency.exponentialRampToValueAtTime(35, now + 0.4);
        rumbleGain.gain.setValueAtTime(0.25, now);
        rumbleGain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
        rumble.connect(rumbleGain);
        rumbleGain.connect(audioContext.destination);
        rumble.start(now);
        rumble.stop(now + 0.4);
        
        // Vibrations
        const bufferSize = audioContext.sampleRate * 0.3;
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
          const t = i / audioContext.sampleRate;
          const vibration = Math.sin(t * Math.PI * 2 * 80) * Math.sin(t * Math.PI * 2 * 15);
          const noise = (Math.random() * 2 - 1) * 0.2;
          data[i] = (vibration * 0.6 + noise) * (1 - t / 0.3);
        }
        
        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        const filter = audioContext.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 300;
        const gain = audioContext.createGain();
        gain.gain.value = 0.2;
        source.connect(filter);
        filter.connect(gain);
        gain.connect(audioContext.destination);
        source.start(now);
      }
      break;
      
    case 'raven_caw': // Croassement sinistre du corbeau
      {
        const duration = 0.5;
        const bufferSize = audioContext.sampleRate * duration;
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
          const t = i / audioContext.sampleRate;
          // Croassement rauque "CRAW"
          const freq = 400 + Math.sin(t * 30) * 150; // Modulation irrÃ©guliÃ¨re
          const caw = Math.sin(t * Math.PI * 2 * freq);
          // Texture rauque avec bruit
          const noise = (Math.random() * 2 - 1) * 0.4;
          // Harmoniques sombres
          const dark = Math.sin(t * Math.PI * 2 * freq * 0.5) * 0.3;
          const envelope = Math.exp(-t * 5) * (1 + Math.sin(t * 20) * 0.2);
          data[i] = (caw * 0.5 + noise + dark) * envelope;
        }
        
        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        const filter = audioContext.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = 600;
        filter.Q.value = 2;
        const gain = audioContext.createGain();
        gain.gain.value = 0.32;
        source.connect(filter);
        filter.connect(gain);
        gain.connect(audioContext.destination);
        source.start(now);
      }
      break;
      
    case 'raven_flap': // Battement d'ailes puissant
      {
        const duration = 0.25;
        const bufferSize = audioContext.sampleRate * duration;
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
          const t = i / audioContext.sampleRate;
          // Whoosh d'air
          const whoosh = (Math.random() * 2 - 1) * Math.exp(-t * 15);
          // Battement grave
          const flap = Math.sin(t * Math.PI * 2 * 80) * Math.exp(-t * 10);
          data[i] = whoosh * 0.7 + flap * 0.5;
        }
        
        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        const filter = audioContext.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 1200;
        const gain = audioContext.createGain();
        gain.gain.value = 0.18;
        source.connect(filter);
        filter.connect(gain);
        gain.connect(audioContext.destination);
        source.start(now);
      }
      break;
      
    case 'raven_feather': // Plumes empoisonnÃ©es lancÃ©es
      {
        const duration = 0.3;
        const bufferSize = audioContext.sampleRate * duration;
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
          const t = i / audioContext.sampleRate;
          // Sifflement aigu des plumes
          const whistle = Math.sin(t * Math.PI * 2 * (2000 - t * 1000));
          // Bruissement
          const rustle = (Math.random() * 2 - 1) * 0.5;
          const envelope = Math.exp(-t * 8);
          data[i] = (whistle * 0.4 + rustle) * envelope;
        }
        
        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        const filter = audioContext.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 1000;
        const gain = audioContext.createGain();
        gain.gain.value = 0.22;
        source.connect(filter);
        filter.connect(gain);
        gain.connect(audioContext.destination);
        source.start(now);
      }
      break;
      
    case 'spider_skitter': // DÃ©placement rapide de l'araignÃ©e
      {
        const duration = 0.2;
        const bufferSize = audioContext.sampleRate * duration;
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
          const t = i / audioContext.sampleRate;
          // Cliquetis rapides des pattes
          const clicks = (Math.random() > 0.5 ? Math.random() * 0.6 : 0);
          // Grattement aigu
          const scratch = Math.sin(t * Math.PI * 2 * (800 + Math.random() * 400)) * 0.3;
          const envelope = Math.exp(-t * 12);
          data[i] = (clicks + scratch) * envelope;
        }
        
        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        const filter = audioContext.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 600;
        const gain = audioContext.createGain();
        gain.gain.value = 0.15;
        source.connect(filter);
        filter.connect(gain);
        gain.connect(audioContext.destination);
        source.start(now);
      }
      break;
      
    case 'spider_web': // Lancer de toile
      {
        const duration = 0.35;
        const bufferSize = audioContext.sampleRate * duration;
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
          const t = i / audioContext.sampleRate;
          // Sifflement de la toile lancÃ©e
          const whistle = Math.sin(t * Math.PI * 2 * (1500 - t * 800));
          // Texture collante
          const sticky = (Math.random() * 2 - 1) * 0.3;
          const envelope = Math.exp(-t * 6);
          data[i] = (whistle * 0.5 + sticky) * envelope;
        }
        
        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        const filter = audioContext.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = 1000;
        filter.Q.value = 1.5;
        const gain = audioContext.createGain();
        gain.gain.value = 0.2;
        source.connect(filter);
        filter.connect(gain);
        gain.connect(audioContext.destination);
        source.start(now);
      }
      break;
      
    case 'spider_hiss': // Sifflement agressif de l'araignÃ©e
      {
        const duration = 0.4;
        const bufferSize = audioContext.sampleRate * duration;
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
          const t = i / audioContext.sampleRate;
          // Sifflement aigu et menaÃ§ant
          const hiss = (Math.random() * 2 - 1);
          // Modulation pour effet crÃ©pu
          const modulation = Math.sin(t * 150 * Math.PI) * 0.3;
          const envelope = 1 - Math.pow(t / duration, 2);
          data[i] = (hiss * 0.7 + modulation) * envelope;
        }
        
        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        const filter = audioContext.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 3000;
        const gain = audioContext.createGain();
        gain.gain.value = 0.25;
        source.connect(filter);
        filter.connect(gain);
        gain.connect(audioContext.destination);
        source.start(now);
      }
      break;
      
    case 'reaper_laugh': // Rire sinistre de la Faucheuse
      {
        const duration = 0.8;
        const bufferSize = audioContext.sampleRate * duration;
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
          const t = i / audioContext.sampleRate;
          // Rire grave et sinistre avec modulation
          const laughFreq = 150 + Math.sin(t * 12 * Math.PI) * 50;
          const laugh = Math.sin(t * Math.PI * 2 * laughFreq);
          // Texture spectrale
          const spectral = Math.sin(t * Math.PI * 2 * laughFreq * 3) * 0.3;
          // Bruit d'outre-tombe
          const darkness = (Math.random() * 2 - 1) * 0.2;
          const envelope = Math.sin(t / duration * Math.PI) * 0.9;
          data[i] = (laugh * 0.6 + spectral + darkness) * envelope;
        }
        
        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        const filter = audioContext.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 500;
        filter.Q.value = 2;
        const gain = audioContext.createGain();
        gain.gain.value = 0.28;
        source.connect(filter);
        filter.connect(gain);
        gain.connect(audioContext.destination);
        source.start(now);
      }
      break;
      
    case 'reaper_bone': // Ossements qui tombent et s'entrechoquent
      {
        const duration = 0.4;
        const bufferSize = audioContext.sampleRate * duration;
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
          const t = i / audioContext.sampleRate;
          // Cliquetis d'os secs
          const click1 = Math.sin(t * Math.PI * 2 * 800) * Math.exp(-t * 15);
          const click2 = Math.sin(t * Math.PI * 2 * 1200) * Math.exp(-t * 12) * 0.5;
          // Chocs multiples
          const rattle = (Math.random() > 0.7 ? Math.random() * 0.4 : 0);
          data[i] = (click1 + click2 + rattle) * 0.8;
        }
        
        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        const filter = audioContext.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 400;
        const gain = audioContext.createGain();
        gain.gain.value = 0.22;
        source.connect(filter);
        filter.connect(gain);
        gain.connect(audioContext.destination);
        source.start(now);
      }
      break;
      
    case 'reaper_coffin': // Cercueil lourd qui tombe
      {
        const duration = 0.6;
        const bufferSize = audioContext.sampleRate * duration;
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
          const t = i / audioContext.sampleRate;
          // Impact sourd et grave
          const thud = Math.sin(t * Math.PI * 2 * (80 - t * 30));
          // Bois qui craque
          const creak = Math.sin(t * Math.PI * 2 * 200) * Math.exp(-t * 5) * 0.4;
          // RÃ©sonance funÃ¨bre
          const rumble = Math.sin(t * Math.PI * 2 * 40) * 0.3;
          const envelope = Math.exp(-t * 3);
          data[i] = (thud * 0.7 + creak + rumble) * envelope;
        }
        
        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        const filter = audioContext.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 350;
        const gain = audioContext.createGain();
        gain.gain.value = 0.3;
        source.connect(filter);
        filter.connect(gain);
        gain.connect(audioContext.destination);
        source.start(now);
      }
      break;
  }
}

// ============================================
// ï¿½ğŸ® CODE DU JEU
// ============================================
const c=document.getElementById('gameCanvas'),ctx=c.getContext('2d'),scoreEl=document.getElementById('score'),cloudsEl=document.getElementById('clouds'),levelEl=document.getElementById('level'),livesEl=document.getElementById('lives'),starStockEl=document.getElementById('starStock'),messageEl=document.getElementById('message'),startBtn=document.getElementById('startButton'),sunEl=document.getElementById('sun'),motivationEl=document.getElementById('motivationText');

// Initialiser le texte de motivation traduit
if (motivationEl && typeof t === 'function') {
  motivationEl.textContent = '"' + t('intro') + '"';
}

// Initialiser le tÃ©moignage traduit
updateTestimonyContent();

let state='start',score=0,cloudsCleared=0,level=1,lives=3,lastTime=0,umbrella=false,electric=false,multi=false;
let lastSavedCloudsCount=0;

const player={x:c.width/2,y:c.height-120,w:40,h:30,s:5};

let bullets=[],clouds=[],rain=[],particles=[],powerUps=[],hearts=[],touchX=null,touchY=null,shooting=false,lastShot=0,bonusItems=[],lastCloudSpawn=0;
let isBonusLevel=false,bonusItemsCollected=0,bonusItemsTarget=20,bonusLevelNumber=0;
let cloudKillCount=0,fallingPowerUps=[],collectedStar=false,lastClickTime=0,shockwaves=[];
let umbrellaEndTime=0,electricEndTime=0,multiEndTime=0,lastElectricShock=0;
let bossShootCount=0; // Compteur de tirs pendant les combats de boss (power-up tous les 10 tirs)

// Gestionnaire de boss
let bossManager = new BossManager();

// Nuages de fond dÃ©coratifs
let backgroundClouds = [];

// Gouttes de pluie dÃ©coratives pour le niveau 7
let decorativeRain = [];

// Fonction pour crÃ©er une goutte de pluie dÃ©corative
function decorativeRainDrop() {
  return {
    x: Math.random() * c.width,
    y: -Math.random() * c.height,
    speed: 5 + Math.random() * 3,
    length: 10 + Math.random() * 10,
    opacity: 0.3 + Math.random() * 0.4
  };
}

// Fonction pour dessiner une goutte de pluie dÃ©corative
function drawDecorativeRain(drop) {
  ctx.strokeStyle = `rgba(173, 216, 230, ${drop.opacity})`;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(drop.x, drop.y);
  ctx.lineTo(drop.x, drop.y + drop.length);
  ctx.stroke();
}

// Fonction pour crÃ©er un power-up tombant du ciel
function createFallingPowerUp(type) {
  return {
    type: type, // 'heart', 'rainbow', 'star'
    x: 50 + Math.random() * (c.width - 100),
    y: -40,
    w: 30,
    h: 30,
    speed: 2,
    angle: 0
  };
}

// Fonction pour dessiner les power-ups
function drawPowerUp(powerup) {
  ctx.save();
  ctx.translate(powerup.x + powerup.w/2, powerup.y + powerup.h/2);
  ctx.rotate(powerup.angle || 0);
  
  // Afficher l'icÃ´ne correspondante
  const fontSize = powerup.w || 25; // Adapter la taille Ã  la largeur du power-up
  ctx.font = `${fontSize}px Arial`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  if(powerup.type === 'heart') {
    ctx.fillText('ğŸ’–', 0, 0);
  } else if(powerup.type === 'rainbow') {
    ctx.fillText('ğŸŒˆ', 0, 0);
  } else if(powerup.type === 'star') {
    ctx.fillText('â­', 0, 0);
  } else if(powerup.type === 'electric') {
    ctx.fillText('âš¡', 0, 0);
  } else if(powerup.type === 'umbrella') {
    ctx.fillText('â˜‚ï¸', 0, 0);
  } else if(powerup.type === 'multishot') {
    ctx.fillText('ğŸ”«', 0, 0);
  }
  
  ctx.restore();
}

// Fonction pour crÃ©er une onde de choc
function createShockwave(x, y) {
  return {
    x: x,
    y: y,
    radius: 0,
    maxRadius: Math.max(c.width, c.height),
    opacity: 1,
    speed: 15
  };
}

// Fonction pour dessiner une onde de choc
function drawShockwave(wave) {
  // SÃ©curitÃ© : s'assurer que le rayon est positif
  const safeRadius = Math.max(0, wave.radius);
  if (safeRadius === 0) return;

  ctx.save();
  ctx.strokeStyle = `rgba(255, 215, 0, ${wave.opacity})`;
  ctx.lineWidth = 4;
  ctx.shadowBlur = 20;
  ctx.shadowColor = 'rgba(255, 215, 0, 0.8)';
  ctx.beginPath();
  ctx.arc(wave.x, wave.y, safeRadius, 0, Math.PI * 2);
  ctx.stroke();

  // DeuxiÃ¨me cercle intÃ©rieur
  ctx.strokeStyle = `rgba(255, 255, 255, ${wave.opacity * 0.6})`;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(wave.x, wave.y, safeRadius * 0.8, 0, Math.PI * 2);
  ctx.stroke();
  ctx.restore();
}

// Fonction pour adapter le canvas au format portrait mobile
function resizeCanvas() {
  const container = document.getElementById('gameContainer');
  const containerWidth = container.clientWidth;
  const containerHeight = container.clientHeight;
  
  // DÃ©tecter les appareils mobiles
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  
  // RÃ©solution minimale garantie pour faibles mobiles
  const MIN_WIDTH = 320;  // iPhone SE et anciens Android
  const MIN_HEIGHT = 480;
  const MAX_WIDTH = 480;  // Limite haute pour performances
  
  // Ratio aspect idÃ©al (9:16 portrait)
  const ASPECT_RATIO = 9 / 16;
  
  if(isMobile || containerWidth < containerHeight) {
    // Mode portrait mobile : adapter Ã  la rÃ©solution de l'Ã©cran
    const screenWidth = window.innerWidth || screen.width;
    const screenHeight = window.innerHeight || screen.height;
    
    // Calculer les dimensions optimales
    let targetWidth = Math.max(MIN_WIDTH, Math.min(screenWidth, containerWidth, MAX_WIDTH));
    let targetHeight = Math.max(MIN_HEIGHT, Math.min(screenHeight, containerHeight));
    
    // Pour trÃ¨s petits Ã©crans, rÃ©duire la rÃ©solution interne pour performances
    if (screenWidth < 375 || screenHeight < 667) {
      // Appareils comme iPhone SE, anciens Android
      targetWidth = Math.min(targetWidth, 360);
      targetHeight = Math.min(targetHeight, 640);
      
      // Activer le mode performance sur trÃ¨s faibles appareils
      if (screenWidth < 340) {
        targetWidth = MIN_WIDTH;
        targetHeight = MIN_HEIGHT;
      }
    }
    
    c.width = targetWidth;
    c.height = targetHeight;
    
    // Ajuster la taille d'affichage via CSS pour remplir le conteneur
    c.style.width = '100%';
    c.style.height = '100%';
    c.style.imageRendering = screenWidth < 375 ? 'pixelated' : 'auto';
  } else {
    // Mode desktop : maintenir le ratio aspect pour Ã©viter l'Ã©tirement
    const containerRatio = containerWidth / containerHeight;
    
    let targetWidth, targetHeight;
    
    if (containerRatio > ASPECT_RATIO) {
      // Container plus large : limiter par la hauteur
      targetHeight = Math.min(containerHeight, 800);
      targetWidth = Math.round(targetHeight * ASPECT_RATIO);
    } else {
      // Container plus haut : limiter par la largeur
      targetWidth = Math.min(containerWidth, MAX_WIDTH);
      targetHeight = Math.round(targetWidth / ASPECT_RATIO);
    }
    
    c.width = targetWidth;
    c.height = targetHeight;
    
    // Centrer le canvas sans Ã©tirement
    c.style.width = targetWidth + 'px';
    c.style.height = targetHeight + 'px';
    c.style.imageRendering = 'auto';
  }
  
  player.x = c.width / 2;
  player.y = c.height - 120;
  
  // RecrÃ©er les nuages de fond avec les nouvelles dimensions
  backgroundClouds = [];
  for(let i = 0; i < 8; i++) {
    backgroundClouds.push(createBackgroundCloud());
  }
}

function createBackgroundCloud() {
  return {
    x: Math.random() * c.width,
    y: Math.random() * c.height * 0.6,
    size: 15 + Math.random() * 25,
    speed: 0.05 + Math.random() * 0.15,
    opacity: 0.3 + Math.random() * 0.3
  };
}

resizeCanvas();

// Adapter le canvas lors du redimensionnement ou changement d'orientation
window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', () => {
  setTimeout(resizeCanvas, 100);
});


function drawBackgroundCloud(bgCloud) {
  ctx.globalAlpha = bgCloud.opacity;
  ctx.fillStyle = '#ffffff';
  ctx.beginPath();
  ctx.arc(bgCloud.x, bgCloud.y, bgCloud.size, 0, Math.PI * 2);
  ctx.arc(bgCloud.x + bgCloud.size * 0.7, bgCloud.y - bgCloud.size * 0.3, bgCloud.size * 0.8, 0, Math.PI * 2);
  ctx.arc(bgCloud.x + bgCloud.size * 1.4, bgCloud.y, bgCloud.size * 0.9, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 1;
}

function updateBackgroundClouds() {
  backgroundClouds.forEach(bgCloud => {
    bgCloud.x += bgCloud.speed;
    if(bgCloud.x > c.width + bgCloud.size * 2) {
      bgCloud.x = -bgCloud.size * 2;
      bgCloud.y = Math.random() * c.height * 0.6;
    }
  });
}

function cloud(){
  // Appliquer les multiplicateurs de difficultÃ©
  const adjustedSpeed = applyDifficulty('cloudSpeed', currentLevelConfig.cloudSpeed);
  const adjustedShootingClouds = applyDifficulty('shootingClouds', currentLevelConfig.shootingClouds);

  const shoot=Math.random()>(1-adjustedShootingClouds);
  return{
    x:Math.random()*(c.width-55),
    y:-40,
    w:52,
    h:32,
    s:adjustedSpeed.min+Math.random()*(adjustedSpeed.max-adjustedSpeed.min),
    c:shoot?'#7f8c8d':'#95a5a6',
    shoot:shoot,
    lastShot:Date.now(),
    delay:3000+Math.random()*3000 // OPTIMISATION: DÃ©lai augmentÃ© pour rÃ©duire spam
  };
}

function bonusItem(){
  const types=[
    {name:'heart',icon:'â¤ï¸',points:500,color:'#e74c3c'},
    {name:'star',icon:'â­',points:300,color:'#f1c40f'},
    {name:'cross',icon:'âœï¸',points:1000,color:'#ecf0f1'},
    {name:'coin',icon:'ğŸ’°',points:-200,color:'#95a5a6'},
    {name:'rainbow',icon:'ğŸŒˆ',points:1500,color:'#9b59b6'}
  ];
  const type=types[Math.floor(Math.random()*types.length)];
  return{
    x:Math.random()*(c.width-40),
    y:-40,
    w:35,
    h:35,
    s:2+Math.random()*1.5,
    type:type.name,
    icon:type.icon,
    points:type.points,
    color:type.color,
    rotation:0,
    rotSpeed:(Math.random()-0.5)*0.1
  };
}

function rainDrop(x,y){
  // Appliquer les multiplicateurs de difficultÃ©
  const adjustedRainSpeed = applyDifficulty('rainSpeed', currentLevelConfig.rainSpeed);

  return{
    x:x,
    y:y,
    w:3,
    h:8,
    s:adjustedRainSpeed.min+Math.random()*(adjustedRainSpeed.max-adjustedRainSpeed.min),
    c:'#e74c3c'
  };
}

function powerUp(x,y){const types=['umbrella','electric','multishot'],type=types[Math.floor(Math.random()*types.length)],colors={umbrella:'#e74c3c',electric:'#9b59b6',multishot:'#f39c12'};return{x:x,y:y,w:25,h:25,s:2,type:type,c:colors[type]};}

function bullet(x,y,color,width){return{x:x,y:y,w:width||4,h:12,s:8,c:color||'#f1c40f'};}

function heart(){return{x:player.x+18+Math.random()*8,y:player.y+10+Math.random()*5,vx:(Math.random()-0.5)*1.5,vy:-2.5-Math.random()*1.2,size:12+Math.random()*6,life:1,decay:0.006,c:'#e74c3c',rot:0,rotS:(Math.random()-0.5)*0.1};}

function particle(x,y){return{x:x,y:y,vx:(Math.random()-0.5)*6,vy:(Math.random()-0.5)*6,life:1,decay:0.04,c:`hsl(${45+Math.random()*30},80%,70%)`};}

function drawBonusItem(item){
  ctx.save();
  ctx.translate(item.x+item.w/2,item.y+item.h/2);
  ctx.rotate(item.rotation);
  ctx.shadowBlur=15;
  ctx.shadowColor=item.color;
  ctx.font='30px Arial';
  ctx.textAlign='center';
  ctx.textBaseline='middle';
  ctx.fillText(item.icon,0,0);
  ctx.shadowBlur=0;
  ctx.restore();
}

function drawPlayer(){
let glow='#f1c40f',intensity=20;
let haloColor='rgba(241,196,15,0.2)';
let haloGlow='#f1c40f';

if(umbrella){
  glow='#e74c3c';
  intensity=30;
  haloColor='rgba(231,76,60,0.2)';
  haloGlow='#e74c3c';
}else if(electric){
  glow='#9b59b6';
  intensity=28;
  haloColor='rgba(155,89,182,0.2)';
  haloGlow='#9b59b6';
}else if(multi){
  glow='#f39c12';
  intensity=23;
  haloColor='rgba(243,156,18,0.2)';
  haloGlow='#f39c12';
}else if(shooting){
  // Changement de couleur quand on tire
  glow='#3498db';
  intensity=25;
  haloColor='rgba(52,152,219,0.3)';
  haloGlow='#3498db';
}

ctx.shadowBlur=30;ctx.shadowColor=haloGlow;ctx.fillStyle=haloColor;ctx.beginPath();ctx.arc(player.x+20,player.y+15,40,0,Math.PI*2);ctx.fill();

ctx.shadowBlur=intensity;ctx.shadowColor=glow;ctx.fillStyle='#ffffff';

ctx.strokeStyle='#2c3e50';ctx.lineWidth=1;

const beat=Math.sin(Date.now()*(electric?0.025:0.015))*2;

ctx.beginPath();ctx.moveTo(player.x+20,player.y+8);ctx.lineTo(player.x+15,player.y+22);ctx.lineTo(player.x+25,player.y+22);ctx.closePath();ctx.fill();ctx.stroke();

ctx.beginPath();ctx.moveTo(player.x+15,player.y+12);ctx.lineTo(player.x+2,player.y+8+beat);ctx.lineTo(player.x+18,player.y+25);ctx.closePath();ctx.fill();ctx.stroke();

ctx.beginPath();ctx.moveTo(player.x+25,player.y+12);ctx.lineTo(player.x+38,player.y+8-beat);ctx.lineTo(player.x+22,player.y+25);ctx.closePath();ctx.fill();ctx.stroke();

ctx.beginPath();ctx.moveTo(player.x+20,player.y+22);ctx.lineTo(player.x+18,player.y+30);ctx.lineTo(player.x+22,player.y+30);ctx.closePath();ctx.fill();ctx.stroke();

ctx.shadowBlur=40;ctx.shadowColor='rgba(241,196,15,0.4)';ctx.fillStyle='rgba(255,255,255,0.1)';ctx.beginPath();ctx.arc(player.x+20,player.y+15,50,0,Math.PI*2);ctx.fill();ctx.shadowBlur=0;

if(umbrella){
  // Dessiner l'arc-en-ciel au-dessus de la colombe
  ctx.save();
  ctx.lineWidth = 3;
  const rainbowColors = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#9400d3'];
  const centerX = player.x + 20;
  const centerY = player.y - 10;
  
  for(let i = 0; i < rainbowColors.length; i++) {
    ctx.strokeStyle = rainbowColors[i];
    ctx.shadowBlur = 10;
    ctx.shadowColor = rainbowColors[i];
    ctx.beginPath();
    ctx.arc(centerX, centerY, 25 - i * 3, 0, Math.PI, true);
    ctx.stroke();
  }
  ctx.shadowBlur = 0;
  ctx.restore();
  
  // Parapluie en-dessous de l'arc-en-ciel
  ctx.strokeStyle='rgba(231,76,60,0.7)';
  ctx.lineWidth=2;
  ctx.shadowBlur=8;
  ctx.shadowColor='#e74c3c';
  ctx.beginPath();
  ctx.arc(player.x+20,player.y-5,15,0,Math.PI,true);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(player.x+20,player.y-5);
  ctx.lineTo(player.x+20,player.y+8);
  ctx.stroke();
  ctx.shadowBlur=0;
}

// Afficher le compteur d'Ã©toiles au-dessus de la colombe
if(starCount > 0){
  ctx.save();
  const starY = player.y - 25 + Math.sin(Date.now() * 0.005) * 3;
  ctx.shadowBlur = 15;
  ctx.shadowColor = '#ffd700';
  ctx.fillStyle = '#ffd700';
  ctx.strokeStyle = '#ffaa00';
  ctx.lineWidth = 2;
  ctx.beginPath();
  for(let i = 0; i < 5; i++) {
    const angle = (i * 4 * Math.PI / 5) - Math.PI / 2;
    const x = player.x + 20 + Math.cos(angle) * 12;
    const y = starY + Math.sin(angle) * 12;
    if(i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  
  // Afficher le compteur Ã  cÃ´tÃ© de l'Ã©toile avec fade rapide
  const timeSinceChange = Date.now() - lastStarChangeTime;
  const fadeTime = 1500; // DisparaÃ®t aprÃ¨s 1.5 secondes
  if(timeSinceChange < fadeTime) {
    const opacity = Math.max(0, 1 - (timeSinceChange / fadeTime));
    ctx.globalAlpha = opacity;
    ctx.font = 'bold 16px Arial';
    ctx.fillStyle = '#ffffff';
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 3;
    ctx.strokeText(`x${starCount}`, player.x + 35, starY + 5);
    ctx.fillText(`x${starCount}`, player.x + 35, starY + 5);
    ctx.globalAlpha = 1;
  }
  
  ctx.shadowBlur = 0;
  ctx.restore();
}
}

function drawCloud(cl){ctx.fillStyle=cl.c;ctx.shadowBlur=3;ctx.shadowColor=cl.c;ctx.beginPath();ctx.arc(cl.x+10,cl.y+15,10,0,Math.PI*2);ctx.arc(cl.x+25,cl.y+10,12,0,Math.PI*2);ctx.arc(cl.x+40,cl.y+15,10,0,Math.PI*2);ctx.arc(cl.x+20,cl.y+20,8,0,Math.PI*2);ctx.fill();if(cl.shoot){ctx.fillStyle='#34495e';ctx.beginPath();ctx.arc(cl.x+25,cl.y+12,3,0,Math.PI*2);ctx.fill();}ctx.shadowBlur=0;}

// OPTIMISATION: shadowBlur appliquÃ© en batch dans render()
function drawRain(r){ctx.fillStyle=r.c;ctx.beginPath();ctx.ellipse(r.x,r.y,2,4,0,0,Math.PI*2);ctx.fill();}

function drawPowerUp(p){ctx.strokeStyle=p.c;ctx.fillStyle=p.c;ctx.lineWidth=2;if(p.type==='umbrella'){ctx.beginPath();ctx.arc(p.x+12,p.y+8,12,0,Math.PI,true);ctx.stroke();ctx.beginPath();ctx.moveTo(p.x+12,p.y+8);ctx.lineTo(p.x+12,p.y+20);ctx.stroke();}else if(p.type==='speed'){ctx.beginPath();ctx.moveTo(p.x+8,p.y+2);ctx.lineTo(p.x+12,p.y+2);ctx.lineTo(p.x+6,p.y+12);ctx.lineTo(p.x+10,p.y+12);ctx.lineTo(p.x+4,p.y+22);ctx.lineTo(p.x+16,p.y+10);ctx.lineTo(p.x+12,p.y+10);ctx.lineTo(p.x+18,p.y+2);ctx.closePath();ctx.fill();}else{for(let i=0;i<3;i++){const o=i*6;ctx.beginPath();ctx.arc(p.x+6+o,p.y+12,4,0,Math.PI*2);ctx.fill();}}}

function drawBullet(b){ctx.fillStyle=b.c;ctx.shadowBlur=8;ctx.shadowColor=b.c;ctx.fillRect(b.x,b.y,b.w,b.h);ctx.shadowBlur=0;}

function drawHeart(h){ctx.save();ctx.globalAlpha=h.life;ctx.translate(h.x,h.y);ctx.rotate(h.rot);ctx.fillStyle=h.c;ctx.shadowBlur=8;ctx.shadowColor=h.c;const s=h.size;ctx.beginPath();ctx.arc(-s/4,-s/4,s/4,0,Math.PI*2);ctx.arc(s/4,-s/4,s/4,0,Math.PI*2);ctx.moveTo(0,s/4);ctx.lineTo(-s/2,-s/8);ctx.lineTo(s/2,-s/8);ctx.closePath();ctx.fill();ctx.shadowBlur=0;ctx.restore();}

function drawParticle(p){ctx.globalAlpha=p.life;ctx.fillStyle=p.c;ctx.fillRect(p.x,p.y,3,3);ctx.globalAlpha=1;}

function setSun(mood){sunEl.className=`sun ${mood}`;}

// Fonction de collision avec marge de prÃ©cision
function hit(a,b,margin=0){
  const m = margin || 0;
  return a.x+m < b.x+b.w-m && 
         a.x+a.w-m > b.x+m && 
         a.y+m < b.y+b.h-m && 
         a.y+a.h-m > b.y+m;
}

// Fonction de collision prÃ©cise pour les nuages (avec marge rÃ©duite)
// OPTIMISATION: Early exit rapide pour hitCloud
function hitCloud(player,cloud){
  const margin = 2;
  // VÃ©rifications rapides en premier (plus susceptibles d'Ã©chouer)
  if(player.x+margin >= cloud.x+cloud.w-margin) return false;
  if(player.x+player.w-margin <= cloud.x+margin) return false;
  if(player.y+margin >= cloud.y+cloud.h-margin) return false;
  if(player.y+player.h-margin <= cloud.y+margin) return false;
  return true;
}

function msg(text){messageEl.textContent=text;messageEl.style.opacity='1';const time=Math.max(3000,Math.min(3000+text.length*50,6000));setTimeout(()=>messageEl.style.opacity='0',time);}

// Popup Ã©lÃ©gant dans le canvas (remplace alert)
function showPopup(message, icon = 'âœ¨', type = 'info') {
  const colors = {
    success: { bg: 'rgba(46,204,113,0.95)', border: '#27ae60' },
    error: { bg: 'rgba(231,76,60,0.95)', border: '#c0392b' },
    info: { bg: 'rgba(52,152,219,0.95)', border: '#2980b9' },
    warning: { bg: 'rgba(241,196,15,0.95)', border: '#f39c12' }
  };
  
  const color = colors[type] || colors.info;
  
  const popup = document.createElement('div');
  popup.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.8);
    background: ${color.bg};
    color: white;
    padding: 30px 40px;
    border-radius: 20px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    z-index: 10000;
    text-align: center;
    font-size: 16px;
    line-height: 1.6;
    max-width: 400px;
    border: 3px solid ${color.border};
    animation: popupEnter 0.3s ease-out forwards;
  `;
  
  popup.innerHTML = `
    <div style="font-size: 48px; margin-bottom: 15px;">${icon}</div>
    <div style="white-space: pre-line; font-weight: 500;">${message}</div>
    <button onclick="this.parentElement.remove()" style="
      margin-top: 20px;
      padding: 12px 30px;
      background: rgba(255,255,255,0.2);
      border: 2px solid white;
      border-radius: 10px;
      color: white;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
    " onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'">
      OK
    </button>
  `;
  
  // Ajouter l'animation CSS
  if (!document.getElementById('popupStyle')) {
    const style = document.createElement('style');
    style.id = 'popupStyle';
    style.textContent = `
      @keyframes popupEnter {
        from { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
        to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
      }
    `;
    document.head.appendChild(style);
  }
  
  document.getElementById('gameContainer').appendChild(popup);
  
  // Auto-fermeture aprÃ¨s 5 secondes
  setTimeout(() => {
    if (popup.parentElement) popup.remove();
  }, 5000);
}

let gameStartTime = 0; // Pour mesurer le temps de jeu

function restart(){
  // Sauvegarder les stats de la partie prÃ©cÃ©dente si elle existait
  if (gameStartTime > 0) {
    const survivalTime = Date.now() - gameStartTime;
    saveGameEnd(score, level, cloudsCleared, survivalTime);
  }

  // NE PAS rÃ©initialiser starCount pour conserver le stock entre les parties
  score=0;cloudsCleared=0;lives=3;bullets=[];clouds=[];rain=[];particles=[];powerUps=[];hearts=[];umbrella=false;electric=false;multi=false;totalScore=0;cloudsInLevel=0;bonusItems=[];isBonusLevel=false;bonusItemsCollected=0;bonusLevelNumber=0;fallingPowerUps=[];cloudKillCount=0;collectedStar=false;shockwaves=[];umbrellaEndTime=0;electricEndTime=0;multiEndTime=0;lastElectricShock=0;lastSavedCloudsCount=0;bossSpawnedThisLevel=false;bossDefeatRewardsGiven=false;bossShootCount=0;lastCloudSpawn=0;

  // RÃ©initialiser le boss
  bossManager.reset();

  gameStartTime = Date.now(); // Nouveau dÃ©part

  // Reprendre au niveau sauvegardÃ© basÃ© sur le nombre de nuages
  level = getCurrentLevel(gameData.totalCloudsDestroyed);
  const savedLevelIndex = Math.max(0, level - 1);
  currentLevelIndex = Math.min(savedLevelIndex, LEVELS_CONFIG.length - 1);

  startLevel(currentLevelIndex);

  // IMPORTANT : Recalculer cloudsInLevel pour savoir oÃ¹ on en est dans le niveau actuel
  // Si on Ã©tait en train de combattre un boss, cela permettra de le respawn
  const currentLevelThreshold = LEVEL_DEFINITIONS.find(l => l.id === level)?.threshold || 0;
  cloudsInLevel = gameData.totalCloudsDestroyed - currentLevelThreshold;

  // Si on Ã©tait dÃ©jÃ  Ã  90%+ du niveau, respawn le boss immÃ©diatement
  const currentLevelCloudsToPass = currentLevelConfig.cloudsToPass || 0;
  const bossSpawnThreshold = Math.floor(currentLevelCloudsToPass * 0.9);

  // Boss araignÃ©e niveau 2
  if(level === 2 && cloudsInLevel >= bossSpawnThreshold) {
    levelBeforeBoss = level;
    bossShootCount = 0;
    bossManager.spawnBoss('spider', c.width, c.height);
    msg(t('bosses.spider.intro'));
    playSound('boss_spawn');
    bossSpawnedThisLevel = true;
  }
  // Boss Grim Reaper niveau 4
  else if(level === 4 && cloudsInLevel >= bossSpawnThreshold) {
    levelBeforeBoss = level;
    bossShootCount = 0;
    bossManager.spawnBoss('grim_reaper', c.width, c.height);
    msg(t('bosses.grim_reaper.intro'));
    playSound('boss_spawn');
    bossSpawnedThisLevel = true;
  }
  // Boss poule niveau 6
  else if(level === 6 && cloudsInLevel >= bossSpawnThreshold) {
    levelBeforeBoss = level;
    bossShootCount = 0;
    bossManager.spawnBoss('crazy_chicken', c.width, c.height);
    msg(t('bosses.crazy_chicken.intro'));
    playSound('boss_spawn');
    bossSpawnedThisLevel = true;
  }
  // Boss Wall niveau 8
  else if(level === 8 && cloudsInLevel >= bossSpawnThreshold) {
    levelBeforeBoss = level;
    bossShootCount = 0;
    bossManager.spawnBoss('wall', c.width, c.height);
    msg(t('bosses.wall.intro'));
    playSound('boss_spawn');
    bossSpawnedThisLevel = true;
  }
  // Boss Dark Cloud niveau 10
  else if(level === 10 && cloudsInLevel >= bossSpawnThreshold) {
    levelBeforeBoss = level;
    bossShootCount = 0;
    bossManager.spawnBoss('dark_cloud', c.width, c.height);
    msg(t('bosses.dark_cloud.intro'));
    playSound('boss_spawn');
    bossSpawnedThisLevel = true;
    
    // ğŸŒ§ï¸ DÃ©clencher la tempÃªte au restart
    for(let i = 0; i < 30; i++) {
      rain.push({
        x: Math.random() * c.width,
        y: -Math.random() * c.height,
        l: 15 + Math.random() * 15,
        s: (currentLevelConfig.rainSpeed || 1.0) * 2 * (1 + Math.random() * 0.5)
      });
    }
    // Musique de pluie lancÃ©e uniquement au spawn initial
  }
  // Boss Black Raven niveau 12
  else if(level === 12 && cloudsInLevel >= bossSpawnThreshold) {
    levelBeforeBoss = level;
    bossShootCount = 0;
    bossManager.spawnBoss('black_raven', c.width, c.height);
    msg(t('bosses.black_raven.intro'));
    playSound('boss_spawn');
    bossSpawnedThisLevel = true;
  }
  // Boss serpent FINAL niveau 14
  else if(level === 14 && cloudsInLevel >= bossSpawnThreshold) {
    levelBeforeBoss = level;
    bossShootCount = 0;
    bossManager.spawnBoss('flying_snake', c.width, c.height);
    msg(t('bosses.flying_snake.intro'));
    playSound('boss_spawn');
    bossSpawnedThisLevel = true;
  }

  msg(t('messages.restart'));

  // DÃ©marrer la musique gospel
  if (musicEnabled) {
    playRandomMusic();
  }
}

function startBonusLevel(){
  console.log('ğŸ startBonusLevel appelÃ©e, bonusLevelNumber:', bonusLevelNumber);
  // Supprimer tous les anciens menus de bonus qui pourraient traÃ®ner
  const oldMenus = document.querySelectorAll('[data-bonus-menu]');
  oldMenus.forEach(menu => menu.remove());
  
  isBonusLevel=true;
  bonusItemsCollected=0;
  bonusItemsTarget=20;
  clouds=[];
  rain=[];
  bullets=[];
  bonusItems=[];
  lastCloudSpawn=0;
  
  // RÃ©initialiser le boss pour Ã©viter les conflits
  bossManager.reset();
  bossSpawnedThisLevel = false;
  bossDefeatRewardsGiven = false;
  
  setSun('happy');
  
  // Messages philosophiques depuis les traductions
  const bonusMessages = t('bonus.messages') || [
    "L'amour de l'argent crÃ©e bien des maux, mais utilisÃ© avec sagesse et amour il est une grande source de bÃ©nÃ©diction.",
    "Apprends Ã  aimer ce que tu as dÃ©jÃ  et ne soupire pas jalousement sur ce qui n'est pas Ã  toi.",
    "La vraie richesse est dans le cÅ“ur, ta force est que tu es unique, plus prÃ©cieux que l'or et l'argent.",
    "LibÃ¨re-toi de l'esclavage matÃ©riel, sois vraiment libre, sois un bon gestionnaire sage."
  ];
  
  const message = bonusMessages[bonusLevelNumber - 1] || bonusMessages[0];
  
  // Afficher un message d'introduction qui se ferme automatiquement
  const bonusDiv=document.createElement('div');
  bonusDiv.setAttribute('data-bonus-menu', 'intro');
  bonusDiv.style.cssText=`
    position:absolute;
    top:50%;
    left:50%;
    transform:translate(-50%,-50%);
    width:90%;
    max-width:400px;
    background:linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color:white;
    padding:30px;
    border-radius:25px;
    text-align:center;
    z-index:450;
    box-shadow:0 20px 60px rgba(0,0,0,0.5);
    animation:fadeIn 0.3s ease-in;
    cursor:pointer;
  `;
  
  bonusDiv.innerHTML=`
    <div style="font-size:48px;margin-bottom:15px;">ğŸ</div>
    <h2 style="font-size:24px;margin:0 0 15px 0;font-weight:800;letter-spacing:1px;">
      ${t('bonus.level_title')} ${bonusLevelNumber}
    </h2>
    <p style="font-size:13px;font-style:italic;margin-bottom:20px;line-height:1.6;opacity:0.95;">
      "${message}"
    </p>
    <div style="background:rgba(255,255,255,0.2);padding:15px;border-radius:15px;margin-bottom:15px;">
      <div style="font-size:14px;margin-bottom:8px;font-weight:600;">âœ¨ ${t('bonus.collect_blessings')}</div>
      <div style="font-size:12px;line-height:1.8;">
        â­ +300 | â¤ï¸ +500 | âœï¸ +1000 | ğŸŒˆ +1500
        <div style="margin-top:5px;color:#ffcccc;">ğŸ’° ${t('bonus.coin_trap')}</div>
      </div>
    </div>
    <div style="font-size:16px;font-weight:bold;margin-bottom:15px;">
      ğŸ¯ ${t('bonus.objective')} ${bonusItemsTarget} ${t('bonus.objects')}
    </div>
    <p style="font-size:11px;opacity:0.8;margin:0;">${t('ui.click_to_continue') || 'Clique pour commencer...'}</p>
  `;
  
  document.getElementById('gameContainer').appendChild(bonusDiv);
  
  // Fermer au clic et dÃ©marrer le jeu
  bonusDiv.addEventListener('click', function() {
    bonusDiv.remove();
    state = 'playing';
    lastTime = Date.now();
    requestAnimationFrame(loop);
  });
  
  state='paused';
}

// ğŸ§ª FONCTION TEST - Lancer un niveau bonus directement
window.testBonus = function(num = 1) {
  console.log('ğŸ§ª Test: Lancement niveau bonus', num);
  bonusLevelNumber = num;
  state = 'paused';
  startBonusLevel();
};
console.log('ğŸ§ª Tapez testBonus(1) dans la console pour tester un niveau bonus');

// ğŸ§ª FONCTION TEST - Afficher le menu de victoire d'un boss
window.testBossVictory = function(bossType = 'spider') {
  console.log('ğŸ§ª Test: Menu victoire boss', bossType);
  // Types disponibles: spider, grim_reaper, wall, black_raven, dark_cloud
  showBossVictoryScreen(bossType, () => {
    console.log('ğŸ§ª Test: Menu fermÃ©');
  });
};
console.log('ğŸ§ª Tapez testBossVictory("spider") dans la console pour tester le menu boss');
console.log('ğŸ§ª Boss disponibles: spider, grim_reaper, wall, black_raven, dark_cloud');
console.log('ğŸ§ª Ou en camelCase: spider, grimReaper, wall, blackRaven, darkCloud');

function endBonusLevel(){
  // Supprimer tous les menus de bonus
  const oldMenus = document.querySelectorAll('[data-bonus-menu]');
  oldMenus.forEach(menu => menu.remove());
  
  isBonusLevel=false;
  bonusItems=[];
  
  const bonusScore=bonusItemsCollected*100;
  
  // Sauvegarder les stats du bonus
  if(bonusLevelNumber > 0 && bonusLevelNumber <= 4){
    gameData.bonusLevels.completed[bonusLevelNumber-1] = true;
    if(bonusScore > gameData.bonusLevels.bestScores[bonusLevelNumber-1]){
      gameData.bonusLevels.bestScores[bonusLevelNumber-1] = bonusScore;
    }
    gameData.bonusLevels.totalItemsCollected += bonusItemsCollected;
    saveGameData();
  }
  
  // Ajouter le score bonus au score total
  score += bonusScore;
  saveProgress(level, score, cloudsCleared);
  
  const endDiv=document.createElement('div');
  endDiv.setAttribute('data-bonus-menu', 'end');
  endDiv.style.cssText=`
    position:absolute;
    top:50%;
    left:50%;
    transform:translate(-50%,-50%);
    width:90%;
    max-width:400px;
    background:linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
    color:white;
    padding:30px;
    border-radius:25px;
    text-align:center;
    z-index:450;
    box-shadow:0 20px 60px rgba(0,0,0,0.5);
    animation:fadeIn 0.3s ease-in;
    cursor:pointer;
  `;
  
  endDiv.innerHTML=`
    <div style="font-size:64px;margin-bottom:10px;">ğŸ†</div>
    <h2 style="font-size:24px;margin:0 0 15px 0;font-weight:800;letter-spacing:1px;">
      ${t('bonus.completed_title')}
    </h2>
    <div style="background:rgba(255,255,255,0.2);padding:15px;border-radius:15px;margin-bottom:15px;">
      <p style="font-size:14px;margin:0 0 5px 0;opacity:0.9;">
        ${t('bonus.items_collected')}
      </p>
      <p style="font-size:36px;margin:0;font-weight:800;">
        ${bonusItemsCollected} / ${bonusItemsTarget}
      </p>
    </div>
    <div style="background:rgba(255,255,255,0.3);padding:15px;border-radius:15px;margin-bottom:15px;">
      <p style="font-size:14px;margin:0 0 5px 0;letter-spacing:1px;">
        ${t('bonus.bonus_score')}
      </p>
      <p style="font-size:42px;margin:0;font-weight:800;">+${bonusScore}</p>
    </div>
    <p style="font-size:11px;opacity:0.8;margin:0;">${t('ui.click_to_continue') || 'Clique pour continuer...'}</p>
  `;
  
  document.getElementById('gameContainer').appendChild(endDiv);
  
  // Fermer au clic et reprendre le jeu
  endDiv.addEventListener('click', function() {
    endDiv.remove();
    state = 'playing';
    lastTime = Date.now();
    requestAnimationFrame(loop);
  });
  
  state='paused';
}

function update(dt){
if(state!=='playing')return;

// Mettre Ã  jour les nuages de fond
updateBackgroundClouds();

// Normaliser le delta time (dt en ms, on veut un facteur basÃ© sur 60 FPS = 16.67ms par frame)
const dtFactor = dt / 16.67;

// Mettre Ã  jour le boss s'il est actif
if(bossManager.isBossActive()) {
  bossManager.update(dt, player.x + player.w/2, player.y + player.h/2);

  // ğŸŒ§ï¸ Maintenir la tempÃªte pendant le combat du Dark Cloud (Nuage Sombre)
  if(bossManager.bossType === 'dark_cloud') {
    // Ajouter constamment de nouvelles gouttes pour maintenir une tempÃªte intense
    if(rain.length < 35 && Math.random() < 0.3) {
      rain.push({
        x: Math.random() * c.width,
        y: -20 - Math.random() * 50,
        l: 15 + Math.random() * 15,
        s: (currentLevelConfig.rainSpeed || 1.0) * 2 * (1 + Math.random() * 0.5)
      });
    }
  }

  // VÃ©rifier collision joueur-toiles d'araignÃ©e
  if(bossManager.checkPlayerCollision(player.x, player.y, player.w, player.h) && !umbrella) {
    lives--;
    playSound('damage');
    msg(t('powerups.damaged'));
    if(lives <= 0) {
      state = 'gameOver';
      setSun('sad');
      stopMusic();
      
      // ğŸ”´ Si le joueur meurt pendant un combat de boss, rÃ©initialiser le boss
      if(bossManager.isBossActive()) {
        bossManager.reset();
        bossDefeatRewardsGiven = false;
        bossShootCount = 0;
        bossSpawnedThisLevel = false; // Permettre de rÃ©affronter le boss
      }
      
      const survivalTime = Date.now() - gameStartTime;
      saveGameEnd(score, level, cloudsCleared, survivalTime);
    }
  }
}

// Mettre Ã  jour la pluie dÃ©corative (niveau 7)
decorativeRain.forEach((drop, i) => {
  drop.y += drop.speed * dtFactor;
  if (drop.y > c.height) {
    decorativeRain[i] = decorativeRainDrop();
  }
});

// OPTIMISATION: Utiliser filter pour fallingPowerUps avec limite 10
fallingPowerUps = fallingPowerUps.filter((pu) => {
  pu.y += pu.speed * dtFactor;
  pu.angle += 0.05 * dtFactor;
  
  // VÃ©rifier la collision avec le joueur
  if(hitCloud(player, pu)) {
    // Activer l'effet du power-up
    if(pu.type === 'heart') {
      lives = Math.min(5, lives + 1);
      playSound('powerup');
      msg(t('powerups.heart'));
    } else if(pu.type === 'rainbow') {
      umbrella = true;
      const remainingUmbrella = umbrella && umbrellaEndTime > Date.now() ? umbrellaEndTime - Date.now() : 0;
      umbrellaEndTime = Date.now() + remainingUmbrella + 8000;
      
      multi = true;
      const remainingMulti = multi && multiEndTime > Date.now() ? multiEndTime - Date.now() : 0;
      multiEndTime = Date.now() + remainingMulti + 8000;
      
      playSound('powerup');
      msg(t('powerups.rainbow'));
    } else if(pu.type === 'star') {
      starCount++;
      lastStarChangeTime = Date.now();
      playSound('powerup');
      msg(t('powerups.star_collected', {count: starCount}));
    } else if(pu.type === 'electric') {
      electric = true;
      const remainingElectric = electric && electricEndTime > Date.now() ? electricEndTime - Date.now() : 0;
      electricEndTime = Date.now() + remainingElectric + 10000;
      lastElectricShock = Date.now();
      playSound('powerup');
      msg('âš¡ Recharge Ã‰lectrique ! Les nuages explosent autour de toi !');
    }
    return false; // Supprimer power-up
  }
  
  return pu.y <= c.height; // Garder si visible
});
if(fallingPowerUps.length > 10) fallingPowerUps.splice(0, fallingPowerUps.length - 10);

if(touchX!==null&&touchY!==null){const currentSpeed=player.s;const targetX=Math.max(20,Math.min(c.width-60,touchX-20));const targetY=Math.max(30,Math.min(c.height-50,touchY-80));player.x+=(targetX-player.x)*0.12*currentSpeed*dtFactor;player.y+=(targetY-player.y)*0.12*currentSpeed*dtFactor;}

// Forcer le joueur Ã  rester dans les limites du canvas
player.x = Math.max(0, Math.min(c.width - player.w, player.x));
player.y = Math.max(0, Math.min(c.height - player.h, player.y));

// GÃ©rer les ondes de choc Ã©lectriques (toutes les 2 secondes)
if(electric && Date.now() - lastElectricShock > 2000) {
  // CrÃ©er une onde de choc depuis la colombe
  shockwaves.push(createShockwave(player.x + player.w/2, player.y + player.h/2));
  playSound('shockwave');
  lastElectricShock = Date.now();
}

// Mode bonus : pas de tir
if(!isBonusLevel&&shooting&&Date.now()-lastShot>(multi?150:200)){
  if(multi){
    // Triple laser : trois larges faisceaux colorÃ©s
    bullets.push(bullet(player.x+2,player.y,'#e74c3c',12));  // Rouge gauche
    bullets.push(bullet(player.x+15,player.y,'#3498db',12)); // Bleu centre
    bullets.push(bullet(player.x+28,player.y,'#f1c40f',12)); // Jaune droite
  }else{
    const bulletColor='#3498db'; // Bleu quand on tire
    bullets.push(bullet(player.x+18,player.y,bulletColor));
  }
  playSound('shoot');
  lastShot=Date.now();

  // IncrÃ©menter le compteur de tirs pendant les combats de boss
  if(bossManager.isBossActive()) {
    bossShootCount++;

    // Faire tomber un power-up tous les 10 tirs pendant un combat de boss
    if(bossShootCount >= 10) {
      const types = ['heart', 'rainbow', 'star', 'electric'];
      const randomType = types[Math.floor(Math.random() * types.length)];
      fallingPowerUps.push(createFallingPowerUp(randomType));
      msg('ğŸ Power-up pendant le combat !');
      bossShootCount = 0; // RÃ©initialiser le compteur
    }
  }
}

// VÃ©rifier l'expiration des power-ups basÃ©s sur le temps (uniquement en jeu)
if(state === 'playing') {
  if(umbrella && umbrellaEndTime > 0 && Date.now() > umbrellaEndTime) umbrella = false;
  if(electric && electricEndTime > 0 && Date.now() > electricEndTime) electric = false;
  if(multi && multiEndTime > 0 && Date.now() > multiEndTime) multi = false;
}

// Spawn selon le mode
if(isBonusLevel){
  // Mode bonus : objets tombent
  if(Math.random()<0.03)bonusItems.push(bonusItem());
  
  // OPTIMISATION: Faire tomber les objets bonus avec filter
  bonusItems = bonusItems.filter((item) => {
    item.y += item.s * dtFactor;
    item.rotation += item.rotSpeed * dtFactor;
    
    if(item.y > c.height) return false;
    
    if(hit(item, player)) {
      score += item.points;
      bonusItemsCollected++;
      playSound('bonus');
      
      // OPTIMISATION: Particules colorÃ©es rÃ©duites de 10 Ã  3
      if(particles.length < 150) {
        for(let j=0; j<3; j++) {
          const p = particle(item.x + item.w/2, item.y + item.h/2);
          p.c = item.color;
          particles.push(p);
        }
      }
      
      msg(`+${item.points} pts ${item.icon}`);
      
      // VÃ©rifier si objectif atteint
      if(bonusItemsCollected >= bonusItemsTarget) {
        playSound('levelup');
        setTimeout(() => endBonusLevel(), 500);
      }
      return false; // Supprimer l'item
    }
    return true; // Garder l'item
  });
}else{
  // OPTIMISATION: Spawn nuages avec timer au lieu de random chaque frame
  const adjustedSpawnRate = applyDifficulty('cloudSpawnRate', currentLevelConfig.cloudSpawnRate);
  const now = Date.now();
  const spawnDelay = 1000 / (adjustedSpawnRate * 60); // Convertir rate en ms
  
  if(now - lastCloudSpawn > spawnDelay && clouds.length < 40) {
    clouds.push(cloud());
    lastCloudSpawn = now;
  }
  // Ancien systÃ¨me de power-ups dÃ©sactivÃ© - utilise maintenant fallingPowerUps
  // if(Math.random()<currentLevelConfig.powerUpRate)powerUps.push(powerUp(Math.random()*(c.width-30),-30));
}

// OPTIMISATION: Nettoyer balles hors Ã©cran et limiter Ã  30
bullets = bullets.filter(b => {
  b.y -= b.s * dtFactor;
  return b.y >= -10;
});
if(bullets.length > 30) bullets.splice(0, bullets.length - 30);

// OPTIMISATION: Utiliser filter pour nettoyer nuages hors Ã©cran
clouds = clouds.filter((cl) => {
  cl.y += cl.s * dtFactor;
  
  // OPTIMISATION: Limite de projectiles rain Ã  100 pour Ã©viter le spam
  if(cl.shoot && Date.now() - cl.lastShot > cl.delay && rain.length < 80) {
    rain.push(rainDrop(cl.x + cl.w/2, cl.y + cl.h));
    cl.lastShot = Date.now();
  }
  
  // Si le bouclier arc-en-ciel est actif et que le nuage touche la colombe
  if(umbrella && hitCloud(player, cl)) {
    // Son magique de transformation
    playSound('rainbow');
    
    // Transformer le nuage en petit cÅ“ur
    hearts.push({
      x: cl.x + cl.w/2,
      y: cl.y + cl.h/2,
      vx: (Math.random() - 0.5) * 4,
      vy: -3 - Math.random() * 2,
      life: 1,
      size: 15,
      c: '#ff69b4',
      rot: 0,
      rotSpeed: (Math.random() - 0.5) * 0.2
    });
    // OPTIMISATION: Particules arc-en-ciel rÃ©duites de 5 Ã  2
    if(particles.length < 150) {
      for(let j=0; j<2; j++){
        particles.push({
          x: cl.x + cl.w/2,
          y: cl.y + cl.h/2,
          vx: (Math.random() - 0.5) * 3,
          vy: (Math.random() - 0.5) * 3,
          life: 1,
          c: ['#ff0000','#ff7f00','#ffff00','#00ff00','#0000ff','#4b0082','#9400d3'][Math.floor(Math.random()*7)]
        });
      }
    }
    score += 50;
    totalScore += 50;
    return false; // Supprimer le nuage
  }
  
  return cl.y <= c.height; // Garder si encore visible
});

// OPTIMISATION: Utiliser filter pour pluie
rain = rain.filter((r) => {
  r.y += r.s * dtFactor;
  if(r.y > c.height) return false;
  if(!umbrella && hit(r, player)) {
    lives--;
    playSound('damage');
    updateStats('totalLivesLost');
    updateStats('deathsByRain');
    const rainMsgs = t('rain');
    msg(rainMsgs[Math.floor(Math.random() * rainMsgs.length)]);
    if(lives <= 0) {
      state = 'gameOver';
      setSun('sad');
      stopMusic();
      const survivalTime = Date.now() - gameStartTime;
      saveGameEnd(score, level, cloudsCleared, survivalTime);
      promptPlayerInfo();
      const isNewRecord = updateBestScore(totalScore);
      if(isNewRecord) {
        msg(t('powerups.new_record', {score: totalScore}));
        showPopup(t('powerups.new_record_popup', {score: totalScore}), 'ğŸ†', 'success');
      }
      msg(t('messages.gameOver'));
    } else {
      setSun('neutral');
      setTimeout(() => {if(state === 'playing') setSun('happy');}, 2000);
    }
    return false;
  }
  return true;
});

// Gestion de la musique de pluie - DÃ‰SACTIVÃ‰E (rÃ©servÃ©e au boss Dark Cloud uniquement)
// La musique de pluie est lancÃ©e uniquement lors du spawn du boss Dark Cloud
if (false) {
  if (rain.length > 5 && bossManager.bossType !== 'dark_cloud') {
    // S'il y a beaucoup de pluie, jouer la musique de pluie
    playRainMusic();
  } else if (rain.length === 0 && bossManager.bossType !== 'dark_cloud') {
    // S'il n'y a plus de pluie, arrÃªter la musique de pluie
    // (Mais ne pas arrÃªter pendant/aprÃ¨s le combat du Dark Cloud - la musique continue jusqu'Ã  la fin)
    stopRainMusic();
  }
}

// OPTIMISATION: Utiliser filter pour powerUps
powerUps = powerUps.filter((p) => {
  p.y += p.s * dtFactor;
  if(p.y > c.height) return false;
  if(hit(p, player)) {
    playSound('powerup');
    updateStats('totalPowerUpsCollected');
    if(p.type === 'umbrella') {
      umbrella = true;
      const remaining = umbrella && umbrellaEndTime > Date.now() ? umbrellaEndTime - Date.now() : 0;
      umbrellaEndTime = Date.now() + remaining + 5000;
      msg(t('powerups.umbrella'));
    } else if(p.type === 'electric') {
      electric = true;
      const remaining = electric && electricEndTime > Date.now() ? electricEndTime - Date.now() : 0;
      electricEndTime = Date.now() + remaining + 10000;
      msg(t('powerups.electric'));
    } else if(p.type === 'multishot') {
      multi = true;
      const remaining = multi && multiEndTime > Date.now() ? multiEndTime - Date.now() : 0;
      multiEndTime = Date.now() + remaining + 6000;
      msg(t('powerups.multishot'));
    }
    return false;
  }
  return true;
});

// OPTIMISATION: Collision balles-nuages avec spatial culling
for(let bi = bullets.length - 1; bi >= 0; bi--){
  const b = bullets[bi];
  let hitDetected = false;
  
  // OPTIMISATION: Ne vÃ©rifier que les nuages proches (spatial culling)
  for(let ci = clouds.length - 1; ci >= 0; ci--){
    const cl = clouds[ci];
    
    // VÃ©rification rapide : distance Y < 50px
    if(Math.abs(b.y - cl.y) > 50) continue;
    
    // VÃ©rification rapide : distance X < 60px
    if(Math.abs(b.x - cl.x) > 60) continue;
    
    // Collision prÃ©cise seulement si proche
    if(hitCloud(b,cl)){
      // OPTIMISATION: RÃ©duit de 8â†’4â†’2 particules avec limite globale
      if(particles.length < 150) {
        for(let i=0;i<2;i++)particles.push(particle(cl.x+cl.w/2,cl.y+cl.h/2));
      }
      
      // Suppression sÃ©curisÃ©e
      bullets.splice(bi,1);
      clouds.splice(ci,1);
      
      // Son
      playSound('hit');
      
      // Score et stats
      score+=100;
      totalScore+=100;
      cloudsCleared++;
      cloudsInLevel++;
      cloudKillCount++;
      
      // Mettre Ã  jour gameData.totalCloudsDestroyed immÃ©diatement
      gameData.totalCloudsDestroyed++;
      
      // Mettre Ã  jour l'affichage des nuages
      if(cloudsEl) cloudsEl.textContent = gameData.totalCloudsDestroyed;
      
      updateStats('totalHits');
      updateStats('totalShots');
      setSun('happy');
      
      // Mode infini : incrÃ©menter le compteur
      if(isInfiniteMode(gameData.totalCloudsDestroyed)) {
        infiniteCloudsCleared++;
        
        // Restaurer le fond de jour et supprimer la nuit Ã©toilÃ©e au passage en mode infini
        if(infiniteCloudsCleared === 1) {
                  restoreDayBackground();
        }
        
        // Afficher verset tous les 100 nuages (100, 200, 300, etc.)
        if(infiniteCloudsCleared % 100 === 0 && state === 'playing') {
                  // ArrÃªter complÃ¨tement le jeu
          const previousState = state;
          state = 'paused';
          showInfiniteVerse(previousState);
          return; // Sortir de la fonction pour arrÃªter le traitement
        }
      }
      
      // VÃ©rifier changement de niveau avec le module
      // IMPORTANT: Ne pas passer au niveau suivant si un boss est actif
      const newLevelInfo = checkLevelUp(gameData.totalCloudsDestroyed - 1, gameData.totalCloudsDestroyed, currentLang);
      if(newLevelInfo && newLevelInfo.id <= 14 && !bossManager.isBossActive()) {
        level = newLevelInfo.id;
        if(levelEl) levelEl.textContent = level;

        // IMPORTANT: Mettre Ã  jour la difficultÃ© du gameplay
        currentLevelIndex = level - 1;
        currentLevelConfig = LEVELS_CONFIG[currentLevelIndex];
        cloudsInLevel = 0; // RÃ©initialiser le compteur de nuages pour ce niveau
        bossSpawnedThisLevel = false; // Permettre le spawn du boss pour ce nouveau niveau
        updateLevelBackground(); // Mettre Ã  jour le fond

      
        // Changer le fond pour les niveaux 13 et 14 (nuit Ã©toilÃ©e avec lune)
        if(level === 13 || level === 14) {
          applyNightSkyBackground(level);
        }

        // Les boss apparaÃ®tront Ã  la fin de leur niveau respectif (voir logique plus bas)

        // Afficher le message de niveau avec les informations du module
        msg(t('powerups.level_up', {level: level, title: newLevelInfo.title}));

        // Ajouter des coeurs
        for(let i=0;i<3;i++)setTimeout(()=>hearts.push(heart()),i*150);

        // Afficher le bouclier de progression aprÃ¨s 1 seconde
        setTimeout(() => {
          const previousState = state;
          state = 'paused';
          showLevelUpMessage(newLevelInfo, previousState);
        }, 1000);
      }
      
      // Faire apparaÃ®tre les boss Ã  la fin de leur niveau respectif (90% de progression)
      // Utilise cloudsInLevel et cloudsToPass pour s'adapter aux diffÃ©rentes difficultÃ©s
      // NE PAS faire apparaÃ®tre de boss pendant les niveaux bonus

      // Boss araignÃ©e: apparaÃ®t Ã  90% du niveau 2
      if(level === 2 && !bossSpawnedThisLevel && !bossManager.isBossActive() && !isBonusLevel) {
        const cloudsToPass = currentLevelConfig.cloudsToPass || 75;
        if(cloudsInLevel >= Math.floor(cloudsToPass * 0.9)) {
          levelBeforeBoss = level; // Sauvegarder le niveau actuel
          bossShootCount = 0; // RÃ©initialiser le compteur de tirs pour ce boss
          bossManager.spawnBoss('spider', c.width, c.height);
          msg(t('bosses.spider.intro'));
          playSound('boss_spawn');
          bossSpawnedThisLevel = true;
        }
      }

      // Boss Grim Reaper: apparaÃ®t Ã  90% du niveau 4
      if(level === 4 && !bossSpawnedThisLevel && !bossManager.isBossActive() && !isBonusLevel) {
        const cloudsToPass = currentLevelConfig.cloudsToPass || 100;
        if(cloudsInLevel >= Math.floor(cloudsToPass * 0.9)) {
          levelBeforeBoss = level;
          bossShootCount = 0;
          bossManager.spawnBoss('grim_reaper', c.width, c.height);
          msg(t('bosses.grim_reaper.intro'));
          playSound('boss_spawn');
          bossSpawnedThisLevel = true;
        }
      }

      // Boss poule: apparaÃ®t Ã  90% du niveau 6
      if(level === 6 && !bossSpawnedThisLevel && !bossManager.isBossActive() && !isBonusLevel) {
        const cloudsToPass = currentLevelConfig.cloudsToPass || 175;
        const spawnAt = Math.floor(cloudsToPass * 0.9);
              if(cloudsInLevel >= spawnAt) {
                  levelBeforeBoss = level; // Sauvegarder le niveau actuel
          bossShootCount = 0; // RÃ©initialiser le compteur de tirs pour ce boss
          bossManager.spawnBoss('crazy_chicken', c.width, c.height);
          msg(t('bosses.crazy_chicken.intro'));
          playSound('boss_spawn');
          bossSpawnedThisLevel = true;
        }
      }

      // Boss Wall: apparaÃ®t Ã  90% du niveau 8
      if(level === 8 && !bossSpawnedThisLevel && !bossManager.isBossActive() && !isBonusLevel) {
        const cloudsToPass = currentLevelConfig.cloudsToPass || 250;
        if(cloudsInLevel >= Math.floor(cloudsToPass * 0.9)) {
          levelBeforeBoss = level;
          bossShootCount = 0;
          bossManager.spawnBoss('wall', c.width, c.height);
          msg(t('bosses.wall.intro'));
          playSound('boss_spawn');
          bossSpawnedThisLevel = true;
        }
      }

      // Boss Dark Cloud: apparaÃ®t Ã  90% du niveau 10
      if(level === 10 && !bossSpawnedThisLevel && !bossManager.isBossActive() && !isBonusLevel) {
        const cloudsToPass = currentLevelConfig.cloudsToPass || 350;
        if(cloudsInLevel >= Math.floor(cloudsToPass * 0.9)) {
          levelBeforeBoss = level;
          bossShootCount = 0;
          bossManager.spawnBoss('dark_cloud', c.width, c.height);
          msg(t('bosses.dark_cloud.intro'));
          playSound('boss_spawn');
          bossSpawnedThisLevel = true;
          
          // DÃ©clencher la tempÃªte
          for(let i = 0; i < 30; i++) {
            rain.push({
              x: Math.random() * c.width,
              y: -Math.random() * c.height,
              l: 15 + Math.random() * 15,
              s: (currentLevelConfig.rainSpeed || 1.0) * 2 * (1 + Math.random() * 0.5)
            });
          }
        }
      }

      // Boss Black Raven: apparaÃ®t Ã  90% du niveau 12
      if(level === 12 && !bossSpawnedThisLevel && !bossManager.isBossActive() && !isBonusLevel) {
        const cloudsToPass = currentLevelConfig.cloudsToPass || 500;
        if(cloudsInLevel >= Math.floor(cloudsToPass * 0.9)) {
          levelBeforeBoss = level;
          bossShootCount = 0;
          bossManager.spawnBoss('black_raven', c.width, c.height);
          msg(t('bosses.black_raven.intro'));
          playSound('boss_spawn');
          bossSpawnedThisLevel = true;
        }
      }

      // Boss Serpent Volant FINAL: apparaÃ®t Ã  90% du niveau 14
      if(level === 14 && !bossSpawnedThisLevel && !bossManager.isBossActive() && !isBonusLevel) {
        const cloudsToPass = currentLevelConfig.cloudsToPass || 999;
        const spawnAt = Math.floor(cloudsToPass * 0.9);
              if(cloudsInLevel >= spawnAt) {
                  levelBeforeBoss = level;
          bossShootCount = 0;
          bossManager.spawnBoss('flying_snake', c.width, c.height);
          msg(t('bosses.flying_snake.intro'));
          playSound('boss_spawn');
          bossSpawnedThisLevel = true;
        }
      }

      // Faire apparaÃ®tre un power-up aprÃ¨s 7 nuages Ã©liminÃ©s
      if(cloudKillCount >= 7 && fallingPowerUps.length === 0) {
        const types = ['heart', 'rainbow', 'star', 'electric'];
        const randomType = types[Math.floor(Math.random() * types.length)];
        fallingPowerUps.push(createFallingPowerUp(randomType));
        cloudKillCount = 0;
      }
      
      // Message alÃ©atoire
      const gameplayMsgs=t('gameplay');
      if(Math.random()<0.1)msg(gameplayMsgs[Math.floor(Math.random()*gameplayMsgs.length)]);
      
      hitDetected = true;
      break; // OPTIMISATION: Sortir immÃ©diatement aprÃ¨s collision
    }
  }

  // VÃ©rifier collision balle-boss si pas encore touchÃ© de nuage
  if(!hitDetected && bossManager.isBossActive()) {
    const result = bossManager.checkBulletCollision(b.x, b.y, b.w, b.h, 10);
    if(result.hit) {
      bullets.splice(bi, 1);
      playSound('hit');

      // Particules
      for(let pi = 0; pi < 5; pi++) {
        particles.push(particle(b.x, b.y));
      }

      // Message si coup critique (Å“il touchÃ©)
      if(result.critical) {
        score += 200;
        totalScore += 200;
        msg('ğŸ’¥ COUP CRITIQUE ! +200 pts');
      } else {
        score += 50;
        totalScore += 50;
      }

      // VÃ©rifier si le boss est vaincu (une seule fois)
      if(bossManager.isBossDefeated() && !bossDefeatRewardsGiven && !isBonusLevel) {
        bossDefeatRewardsGiven = true; // Marquer comme traitÃ©

        // DÃ©verrouiller la sagesse du boss
        if(bossManager.bossType && gameData.bossesDefeated) {
          gameData.bossesDefeated[bossManager.bossType] = true;
          saveGameData();
        }

        // ğŸŒ§ï¸ ArrÃªter la tempÃªte aprÃ¨s la victoire sur le Dark Cloud
        if(bossManager.bossType === 'dark_cloud') {
          rain.length = 0; // Vider toute la pluie
          // NE PAS arrÃªter la musique - elle continue jusqu'Ã  la fin naturelle
          // puis reprendra automatiquement la playlist alÃ©atoire
          msg(t('powerups.storm_cleared'));
        }

        const rewards = bossManager.getBossRewards();
        score += rewards.score;
        totalScore += rewards.score;
        playSound('levelup');

        // ğŸ† Afficher l'Ã©cran de victoire avec le message defeated
        const currentBossType = bossManager.bossType;
        showBossVictoryScreen(currentBossType, () => {
          // AprÃ¨s fermeture de l'Ã©cran de victoire, afficher le message de points
          msg(t('powerups.boss_defeated', {score: rewards.score}));
        });

        // Distribuer les power-ups
        setTimeout(() => {
          rewards.powerUps.forEach((pu, idx) => {
            for(let i = 0; i < pu.count; i++) {
              setTimeout(() => {
                fallingPowerUps.push(createFallingPowerUp(pu.type));
              }, idx * 300 + i * 100);
            }
          });
        }, 500);

        // RÃ©initialiser le boss aprÃ¨s distribution des rÃ©compenses
        // AUGMENTÃ‰: 7000ms (7 secondes) pour laisser le temps de rÃ©cupÃ©rer les power-ups
        setTimeout(() => {
          bossManager.reset();
          bossDefeatRewardsGiven = false; // RÃ©initialiser pour le prochain boss
          bossShootCount = 0; // RÃ©initialiser le compteur de tirs pour le prochain boss
        
          // VÃ©rifier si le joueur peut passer au niveau suivant aprÃ¨s avoir vaincu le boss
          // IMPORTANT: Ne passer qu'au niveau suivant, pas sauter plusieurs niveaux
          const currentLevelFromClouds = getCurrentLevel(gameData.totalCloudsDestroyed);
          if(currentLevelFromClouds > levelBeforeBoss && currentLevelFromClouds <= 14) {
            // Passer seulement au niveau suivant (levelBeforeBoss + 1)
            level = levelBeforeBoss + 1;
            const newLevelInfo = getLevelInfo(level, currentLang);
            if(levelEl) levelEl.textContent = level;

            // IMPORTANT: Mettre Ã  jour la difficultÃ© du gameplay
            currentLevelIndex = level - 1;
            currentLevelConfig = LEVELS_CONFIG[currentLevelIndex];
            cloudsInLevel = 0; // RÃ©initialiser le compteur de nuages pour ce niveau
            bossSpawnedThisLevel = false; // Permettre le spawn du boss pour ce nouveau niveau
            updateLevelBackground(); // Mettre Ã  jour le fond

          
            // Changer le fond pour les niveaux 13 et 14 (nuit Ã©toilÃ©e avec lune)
            if(level === 13 || level === 14) {
              applyNightSkyBackground(level);
            }

            // Afficher le message de niveau avec les informations du module
            msg(t('powerups.level_up', {level: level, title: newLevelInfo.title}));

            // Ajouter des coeurs
            for(let i=0;i<3;i++)setTimeout(()=>hearts.push(heart()),i*150);

            // Afficher le bouclier de progression aprÃ¨s 1 seconde
            setTimeout(() => {
              const previousState = 'playing'; // Toujours revenir en mode playing aprÃ¨s le boss
              state = 'paused';
              
              // PrÃ©parer la callback pour les niveaux bonus aprÃ¨s victoire boss
              let onLevelUpClose = null;
              if(level === 3) {
                bonusLevelNumber = 1;
                console.log('ğŸ Bonus 1 prÃ©parÃ© pour niveau 3 (aprÃ¨s Spider)');
                onLevelUpClose = () => {
                  console.log('ğŸ DÃ©clenchement Bonus 1');
                  startBonusLevel();
                };
              } else if(level === 5) {
                bonusLevelNumber = 2;
                console.log('ğŸ Bonus 2 prÃ©parÃ© pour niveau 5 (aprÃ¨s Grim Reaper)');
                onLevelUpClose = () => {
                  console.log('ğŸ DÃ©clenchement Bonus 2');
                  startBonusLevel();
                };
              } else if(level === 9) {
                bonusLevelNumber = 3;
                console.log('ğŸ Bonus 3 prÃ©parÃ© pour niveau 9 (aprÃ¨s Wall)');
                onLevelUpClose = () => {
                  console.log('ğŸ DÃ©clenchement Bonus 3');
                  startBonusLevel();
                };
              } else if(level === 13) {
                bonusLevelNumber = 4;
                console.log('ğŸ Bonus 4 prÃ©parÃ© pour niveau 13 (aprÃ¨s Black Raven)');
                onLevelUpClose = () => {
                  console.log('ğŸ DÃ©clenchement Bonus 4');
                  startBonusLevel();
                };
              }
              
              showLevelUpMessage(newLevelInfo, previousState, onLevelUpClose);
            }, 1000);
          }
        }, 7000); // Attendre 7 secondes pour laisser le temps de rÃ©cupÃ©rer les power-ups
      }
    }
  }
}

// OPTIMISATION: Utiliser filter pour hearts et limiter Ã  20
hearts = hearts.filter((h) => {
  h.x += h.vx * dtFactor;
  h.y += h.vy * dtFactor;
  h.life -= (h.decay || 0.01) * dtFactor;
  h.rot += (h.rotSpeed || h.rotS || 0) * dtFactor;
  h.vy += 0.015 * dtFactor;
  return h.life > 0;
});
if(hearts.length > 20) hearts.splice(0, hearts.length - 20);

// OPTIMISATION: Limiter le nombre de particules pour Ã©viter les ralentissements
const MAX_PARTICLES = 150; // Limite maximale de particules Ã  l'Ã©cran

// Mettre Ã  jour les particules en boucle inverse pour Ã©viter les problÃ¨mes de splice
for(let i = particles.length - 1; i >= 0; i--) {
  const p = particles[i];
  p.x += p.vx * dtFactor;
  p.y += p.vy * dtFactor;
  p.life -= p.decay * dtFactor;
  if(p.life <= 0) {
    particles.splice(i, 1);
  }
}

// Si trop de particules, supprimer les plus anciennes
if(particles.length > MAX_PARTICLES) {
  particles.splice(0, particles.length - MAX_PARTICLES);
}

// Mettre Ã  jour les ondes de choc et dÃ©truire les nuages
shockwaves.forEach((wave,i)=>{
  wave.radius += wave.speed*dtFactor;
  wave.opacity = 1 - (wave.radius / wave.maxRadius);

  // OPTIMISATION: Limiter les vÃ©rifications aux nuages proches
  const checkRadius = wave.radius + 30; // Rayon de vÃ©rification Ã©tendu
  const prevRadius = wave.radius - wave.speed * dtFactor; // Rayon prÃ©cÃ©dent
  
  // DÃ©truire les nuages touchÃ©s par l'onde de choc
  // OPTIMISATION: Utiliser forEach au lieu de for et filtrer ensuite
  let cloudsDestroyed = 0;
  clouds = clouds.filter(cl => {
    // OPTIMISATION: VÃ©rifier d'abord avec un carrÃ© (plus rapide que cercle)
    const dx = (cl.x + cl.w/2) - wave.x;
    const dy = (cl.y + cl.h/2) - wave.y;
    
    // VÃ©rification rapide avec carrÃ©
    if(Math.abs(dx) > checkRadius || Math.abs(dy) > checkRadius) return true;
    
    // Calcul prÃ©cis de distance seulement si dans le carrÃ©
    const distanceSq = dx * dx + dy * dy; // Distance au carrÃ© (Ã©vite sqrt)
    const radiusSq = wave.radius * wave.radius;
    const innerRadiusSq = prevRadius * prevRadius;
    
    // Si le nuage est dans l'anneau de l'onde (entre rayon prÃ©cÃ©dent et actuel)
    if(distanceSq <= radiusSq + 800 && distanceSq >= innerRadiusSq) { // 800 = (20+20)Â²
      cloudsDestroyed++;
      
      // OPTIMISATION: CrÃ©er UNE SEULE particule au lieu de 3
      if(particles.length < 100) { // Limite globale de particules
        particles.push(particle(cl.x + cl.w/2, cl.y + cl.h/2));
      }

      // Ajouter les points
      score += 100;
      totalScore += 100;
      cloudsCleared++;
      cloudsInLevel++;
      cloudKillCount++;

      return false; // Supprimer le nuage
    }
    return true; // Garder le nuage
  });
  
  // Son seulement si des nuages dÃ©truits (Ã©viter spam)
  if(cloudsDestroyed > 0) {
    playSound('hit');
  }

  // Infliger des dÃ©gÃ¢ts au boss si actif (x5 dÃ©gÃ¢ts)
  if(bossManager.isBossActive() && !wave.hitBoss) {
    const boss = bossManager.currentBoss;
    if(boss) {
      const dx = boss.x - wave.x;
      const dy = boss.y - wave.y;
      const distanceSq = dx * dx + dy * dy;
      const radiusSq = wave.radius * wave.radius;
      const innerRadiusSq = prevRadius * prevRadius;

      // Si le boss est dans l'anneau de l'onde
      if(distanceSq <= radiusSq + 1800 && distanceSq >= innerRadiusSq) { // 1800 = (30+30)Â²
        const isCritical = boss.takeDamage(50, boss.x, boss.y);
        wave.hitBoss = true;

        // OPTIMISATION: RÃ©duire particules de 12 Ã  5
        if(particles.length < 100) {
          for(let pi = 0; pi < 5; pi++) {
            particles.push(particle(boss.x, boss.y));
          }
        }

        if(isCritical) {
          score += 1000;
          totalScore += 1000;
          msg('ğŸ’¥âš¡ ONDE DE CHOC CRITIQUE ! +1000 pts');
        } else {
          score += 500;
          totalScore += 500;
          msg('âš¡ ONDE DE CHOC ! +500 pts');
        }
        playSound('hit');
      }
    }
  }

  if(wave.radius >= wave.maxRadius) shockwaves.splice(i,1);
});

// VÃ©rifier l'expiration des power-ups
const now = Date.now();
if(umbrella && now >= umbrellaEndTime) umbrella = false;
if(electric && now >= electricEndTime) electric = false;
if(multi && now >= multiEndTime) multi = false;

scoreEl.textContent=score;cloudsEl.textContent=cloudsCleared;levelEl.textContent=level;livesEl.textContent=lives;starStockEl.textContent=starCount;
}

function render(){
ctx.clearRect(0,0,c.width,c.height);
if(state==='playing' || state==='levelComplete' || state==='paused'){
    // Dessiner la pluie dÃ©corative en arriÃ¨re-plan (niveau 7)
    decorativeRain.forEach(drawDecorativeRain);

    // Dessiner les nuages de fond dÃ©coratifs
    backgroundClouds.forEach(drawBackgroundCloud);

    // Dessine ensuite tout l'arriÃ¨re-plan du jeu
    clouds.forEach(drawCloud);
    // OPTIMISATION: Batch shadowBlur pour pluie
    ctx.shadowBlur=2;
    ctx.shadowColor='rgba(231,76,60,0.6)';
    rain.forEach(drawRain);
    ctx.shadowBlur=0;
    powerUps.forEach(drawPowerUp);
    bullets.forEach(drawBullet);
    // OPTIMISATION: Glow activÃ© une seule fois pour toutes les particules
    ctx.shadowBlur=5;
    ctx.shadowColor='rgba(255,215,0,0.5)';
    particles.forEach(drawParticle);
    ctx.shadowBlur=0;
    hearts.forEach(drawHeart);

    // Dessiner les power-ups qui tombent
    fallingPowerUps.forEach(drawPowerUp);

    // Dessiner les ondes de choc
    shockwaves.forEach(drawShockwave);

    // Dessiner les objets bonus
    if(isBonusLevel){
      bonusItems.forEach(drawBonusItem);
    }

    // Dessiner le boss avant le joueur (mÃªme en pause pour qu'il soit visible derriÃ¨re le bouclier)
    if(bossManager.isBossActive()) {
      bossManager.draw(ctx);
    }

    // Et la colombe EN DERNIER pour qu'elle soit bien visible devant !
    drawPlayer();

    // Dessiner la barre de vie du boss au-dessus de tout (mÃªme en pause)
    if(bossManager.isBossActive()) {
      bossManager.drawHealthBar(ctx, c.width);
    }
    
    // Afficher la progression
    if(state==='playing'){
      ctx.fillStyle='#2c3e50';
      ctx.font='bold 14px Arial';
      ctx.textAlign='center';
      ctx.shadowColor='rgba(255,255,255,0.8)';
      ctx.shadowBlur=3;
      
      if(isBonusLevel){
        const progress=`ğŸ BONUS - ${bonusItemsCollected}/${bonusItemsTarget} objets`;
        ctx.fillText(progress,c.width/2,c.height-10);
      }else{
        const levelInfo = LEVELS_CONFIG[currentLevelIndex];
        const translatedTitle = t('level_titles.' + levelInfo.id);
        const progress=`${levelInfo.icon} ${translatedTitle} - ${cloudsInLevel}/${currentLevelConfig.cloudsToPass}`;
        ctx.fillText(progress,c.width/2,c.height-10);
      }
      
      ctx.shadowBlur=0;
    }
}
}

function loop(time){
  let dt=time-lastTime;
  // Limiter dt pour Ã©viter des sauts Ã©normes (max 100ms = ~10 FPS minimum)
  if(dt > 100) dt = 16.67; // RÃ©initialiser Ã  60 FPS si pause trop longue
  lastTime=time;
  update(dt);
  render();
  requestAnimationFrame(loop);
}

// Fonction pour obtenir les coordonnÃ©es relatives au canvas
function getCanvasCoords(clientX, clientY) {
  const rect = c.getBoundingClientRect();
  const scaleX = c.width / rect.width;
  const scaleY = c.height / rect.height;
  return {
    x: (clientX - rect.left) * scaleX,
    y: (clientY - rect.top) * scaleY
  };
}

c.addEventListener('touchstart',(e)=>{
  e.preventDefault();
  if(state==='gameOver'||state==='victory') {
    restart();
  } else {
    const now = Date.now();
    // DÃ©tecter le double-clic (moins de 300ms entre deux clics)
    if(starCount > 0 && now - lastClickTime < 300) {
      // Consommer une Ã©toile
      starCount--;
      lastStarChangeTime = Date.now(); // Marquer le moment du changement
      
      // CrÃ©er l'onde de choc depuis la colombe
      shockwaves.push(createShockwave(player.x + player.w/2, player.y + player.h/2));
      playSound('shockwave');
      
      // Activer l'onde de choc
      const numClouds = clouds.length;
      for(let j = 0; j < numClouds; j++) {
        const cl = clouds[j];
        // OPTIMISATION: RÃ©duit de 8 Ã  3 particules par nuage pour performances
        for(let k = 0; k < 3; k++) particles.push(particle(cl.x + cl.w/2, cl.y + cl.h/2));
        score += 100;
        totalScore += 100;
        cloudsCleared++;
        cloudsInLevel++;
      }
      clouds = [];
      msg(t('powerups.star') + ` (${starCount} restantes)`);
      lastClickTime = 0;
    } else {
      lastClickTime = now;
      const t=e.touches[0];
      const coords = getCanvasCoords(t.clientX, t.clientY);
      touchX=coords.x;
      touchY=coords.y;
      shooting=true;
    }
  }
});

c.addEventListener('touchmove',(e)=>{
  e.preventDefault();
  if(e.touches[0]){
    const coords = getCanvasCoords(e.touches[0].clientX, e.touches[0].clientY);
    touchX=coords.x;
    touchY=coords.y;
  }
});

c.addEventListener('touchend',(e)=>{
  e.preventDefault();
  shooting=false;
  touchX=null;
  touchY=null;
});

c.addEventListener('mousemove',(e)=>{
  const coords = getCanvasCoords(e.clientX, e.clientY);
  // Limiter la position Ã  l'intÃ©rieur du canvas
  touchX = Math.max(0, Math.min(c.width, coords.x));
  touchY = Math.max(0, Math.min(c.height, coords.y));
});

c.addEventListener('mousedown',(e)=>{
  if(state==='gameOver'||state==='victory') {
    restart();
  } else {
    const now = Date.now();
    // DÃ©tecter le double-clic (moins de 300ms entre deux clics)
    if(starCount > 0 && now - lastClickTime < 300) {
      // Consommer une Ã©toile
      starCount--;
      lastStarChangeTime = Date.now(); // Marquer le moment du changement
      
      // CrÃ©er l'onde de choc depuis la colombe
      shockwaves.push(createShockwave(player.x + player.w/2, player.y + player.h/2));
      playSound('shockwave');
      
      // Activer l'onde de choc
      const numClouds = clouds.length;
      for(let j = 0; j < numClouds; j++) {
        const cl = clouds[j];
        // OPTIMISATION: RÃ©duit de 8 Ã  3 particules par nuage pour performances
        for(let k = 0; k < 3; k++) particles.push(particle(cl.x + cl.w/2, cl.y + cl.h/2));
        score += 100;
        totalScore += 100;
        cloudsCleared++;
        cloudsInLevel++;
      }
      clouds = [];
      msg(t('powerups.star') + ` (${starCount} restantes)`);
      lastClickTime = 0;
    } else {
      lastClickTime = now;
      shooting=true;
      // S'assurer que la position est dans les limites
      const coords = getCanvasCoords(e.clientX, e.clientY);
      touchX = Math.max(0, Math.min(c.width, coords.x));
      touchY = Math.max(0, Math.min(c.height, coords.y));
    }
  }
});

c.addEventListener('mouseup',()=>shooting=false);

c.addEventListener('mouseleave',()=>{
  shooting=false;
  touchX=null;
  touchY=null;
});

startBtn.addEventListener('click',()=>{
  startBtn.classList.add('hidden');
  const motivationEl=document.querySelector('.motivation');
  if(motivationEl){
    motivationEl.classList.add('compact');
    // Masquer complÃ¨tement aprÃ¨s 3 secondes
    setTimeout(()=>{
      motivationEl.style.opacity='0';
      setTimeout(()=>motivationEl.remove(),500);
    },3000);
  }

  // DÃ©marrer la musique gospel
  if (musicEnabled) {
    playRandomMusic();
  }

  autoHideMenuOnStart();

  // DÃ©marrer au niveau actuel (sans Ã©craser les valeurs)
  const currentLevelIndex = Math.max(0, level - 1);
  const startLevelIndex = Math.min(currentLevelIndex, LEVELS_CONFIG.length - 1);
  startLevel(startLevelIndex);

  // Les boss apparaÃ®tront automatiquement Ã  la fin de leur niveau respectif (pas au dÃ©but)
});

// OPTIMISATION: Event delegation pour menu O/I
const pauseMenu = document.getElementById('pauseMenu');
if(pauseMenu) {
  pauseMenu.addEventListener('click', (e) => {
    const action = e.target.closest('[data-action]')?.dataset.action;
    if(action === 'close') {
      pauseMenu.style.display = 'none';
      document.getElementById('pauseMenuOverlay').style.display = 'none';
    } else if(action === 'pause') {
      togglePause();
      pauseMenu.style.display = 'none';
      document.getElementById('pauseMenuOverlay').style.display = 'none';
    }
  });
}

addEventListener('resize',resizeCanvas);

// Charger les sauvegardes au dÃ©marrage de la page
loadGameData();
loadPlayerProfile();

// Initialiser l'affichage de la difficultÃ©
updateDifficultyButtons();

// Synchroniser le niveau avec le nombre de nuages sauvegardÃ©s
if (gameData.totalCloudsDestroyed > 0) {
  level = getCurrentLevel(gameData.totalCloudsDestroyed);
  if(levelEl) levelEl.textContent = level;
}

// Si pas de donnÃ©es locales mais connectÃ© au cloud, restaurer depuis Supabase
async function restoreFromCloudIfNeeded() {
  const nickname = localStorage.getItem('dovePlayerNickname');
  const email = localStorage.getItem('dovePlayerEmail');
  
  // VÃ©rifier si connectÃ©
  if (nickname && email) {
      
    try {
      // Initialiser Supabase
      if (typeof initSupabaseDove === 'function') {
        await initSupabaseDove();
      }
      
      // Charger les donnÃ©es du cloud
      if (typeof loadDovePlayerData === 'function') {
        const cloudData = await loadDovePlayerData(nickname);
        
              
        if (cloudData.success && cloudData.progress) {
          const progress = cloudData.progress;
          
                  
                  
          // VÃ©rifier si le cloud a des donnÃ©es
          const cloudHasData = progress.highScore > 0 || progress.highestLevelReached > 1;
          const localHasData = gameData.highScore > 0 || gameData.highestLevelReached > 1;
          
                  
          // PRIORITÃ‰ 1: Si le cloud a des donnÃ©es, les utiliser (peu importe le local)
          if (cloudHasData) {
                      
            // Restaurer les donnÃ©es depuis le cloud
            gameData.highScore = progress.highScore || 0;
            gameData.highestLevelReached = progress.highestLevelReached || 1;
            gameData.starStock = progress.starStock || 0;
            gameData.totalCloudsDestroyed = progress.totalCloudsDestroyed || 0;
            gameData.totalGamesPlayed = progress.totalGamesPlayed || 0;
            gameData.stats.totalShots = progress.totalShots || 0;
            gameData.stats.totalHits = progress.totalHits || 0;
            gameData.stats.perfectLevels = progress.perfectLevels || 0;
            
            // Sauvegarder localement
            localStorage.setItem(SAVE_KEY, JSON.stringify(gameData));
            
                      
            // Mettre Ã  jour l'affichage
            score = gameData.highScore;
            level = getCurrentLevel(gameData.totalCloudsDestroyed);
            starCount = gameData.starStock;
            
            const scoreEl = document.getElementById('score');
            const levelEl = document.getElementById('level');
            const starsEl = document.getElementById('starStock');
            const cloudsEl = document.getElementById('clouds');
            
            if (scoreEl) scoreEl.textContent = score;
            if (levelEl) levelEl.textContent = level;
            if (starsEl) starsEl.textContent = starCount;
            if (cloudsEl) cloudsEl.textContent = gameData.totalCloudsDestroyed;
            
            return true;
          }
          // PRIORITÃ‰ 2: Si le cloud est vide mais local a des donnÃ©es, envoyer vers le cloud
          else if (!cloudHasData && localHasData) {
                      
            // Envoyer les donnÃ©es locales vers le cloud
            try {
              if (typeof syncDovePlayerData === 'function') {
                const syncResult = await syncDovePlayerData(nickname, email, gameData);
                if (syncResult.success) {
                                } else {
                                }
              }
            } catch (error) {
                        }
            return false;
          } else {
                    }
        } else {
                }
      }
    } catch (error) {
        }
  }
  return false;
}

// ExÃ©cuter la restauration cloud si nÃ©cessaire
restoreFromCloudIfNeeded().then(restored => {
  if (!restored) {
    }
});

// Initialiser la langue au chargement
updateUILanguage();

// ============================================
// ğŸ’ AFFICHAGE DES STATISTIQUES
// ============================================

/**
 * GÃ©nÃ¨re les icÃ´nes des 14 chapitres avec leur statut (gagnÃ© ou non)
 */
function generateChapterIcons() {
  const chapters = [
    { id: 1, roman: "I", icon: "ğŸŒ…", threshold: 0 },
    { id: 2, roman: "II", icon: "ğŸŒ¬ï¸", threshold: 51 },
    { id: 3, roman: "III", icon: "ğŸ•Šï¸", threshold: 101 },
    { id: 4, roman: "IV", icon: "ğŸ”“", threshold: 151 },
    { id: 5, roman: "V", icon: "ğŸ’", threshold: 201 },
    { id: 6, roman: "VI", icon: "ğŸ’ª", threshold: 251 },
    { id: 7, roman: "VII", icon: "â›ˆï¸", threshold: 301 },
    { id: 8, roman: "VIII", icon: "â¤ï¸", threshold: 351 },
    { id: 9, roman: "IX", icon: "ğŸ¦¸", threshold: 401 },
    { id: 10, roman: "X", icon: "ğŸ¦‹", threshold: 451 },
    { id: 11, roman: "XI", icon: "ğŸ¦", threshold: 551 },
    { id: 12, roman: "XII", icon: "ğŸ“–", threshold: 651 },
    { id: 13, roman: "XIII", icon: "ğŸŒŒ", threshold: 751 },
    { id: 14, roman: "XIV", icon: "âœ¨", threshold: 851 }
  ];
  
  return chapters.map(chapter => {
    const isCompleted = gameData.totalCloudsDestroyed >= chapter.threshold;
    return `
      <div style="
        display:flex;
        flex-direction:column;
        align-items:center;
        justify-content:center;
        padding:10px 6px;
        width:60px;
        min-width:60px;
        background:${isCompleted ? 'linear-gradient(135deg, rgba(46,204,113,0.3), rgba(39,174,96,0.3))' : 'rgba(0,0,0,0.2)'};
        border-radius:12px;
        border:2px solid ${isCompleted ? 'rgba(46,204,113,0.6)' : 'rgba(255,255,255,0.1)'};
        transition:all 0.3s;
        opacity:${isCompleted ? '1' : '0.4'};
      " ${isCompleted ? `onmouseover="this.style.transform='scale(1.1)';this.style.borderColor='rgba(46,204,113,0.9)'" onmouseout="this.style.transform='scale(1)';this.style.borderColor='rgba(46,204,113,0.6)'"` : ''}>
        <div style="font-size:10px;font-weight:bold;color:${isCompleted ? '#2ecc71' : 'rgba(255,255,255,0.3)'};margin-bottom:4px;font-family:'Georgia',serif;">${chapter.roman}</div>
        <div style="font-size:${isCompleted ? '32px' : '12px'};line-height:1;">${isCompleted ? chapter.icon : 'ğŸ”’'}</div>
      </div>
    `;
  }).join('');
}

/**
 * Compte le nombre de chapitres complÃ©tÃ©s
 */
function getCompletedChaptersCount() {
  const thresholds = [0, 51, 101, 151, 201, 251, 301, 351, 401, 451, 551, 651, 751, 851];
  return thresholds.filter(threshold => gameData.totalCloudsDestroyed >= threshold).length;
}

/**
 * GÃ©nÃ¨re les icÃ´nes des sagesses de boss (verrouillÃ©es/dÃ©verrouillÃ©es)
 */
function generateBossWisdomIcons() {
  const bosses = [
    { id: 'spider', emoji: 'ğŸ•·ï¸', name: 'spider' },
    { id: 'flying_snake', emoji: 'ğŸ', name: 'flying_snake' },
    { id: 'crazy_chicken', emoji: 'ğŸ”', name: 'crazy_chicken' },
    { id: 'grim_reaper', emoji: 'ğŸ’€', name: 'grim_reaper' },
    { id: 'wall', emoji: 'ğŸ§±', name: 'wall' },
    { id: 'dark_cloud', emoji: 'â˜ï¸', name: 'dark_cloud' },
    { id: 'black_raven', emoji: 'ğŸ¦â€â¬›', name: 'black_raven' }
  ];
  
  return bosses.map(boss => {
    const isDefeated = gameData.bossesDefeated && gameData.bossesDefeated[boss.id];
    return `
      <div onclick="${isDefeated ? `showBossWisdom('${boss.id}')` : ''}" style="
        display:flex;
        flex-direction:column;
        align-items:center;
        justify-content:center;
        padding:12px 8px;
        width:70px;
        min-width:70px;
        background:${isDefeated ? 'linear-gradient(135deg, rgba(241,196,15,0.3), rgba(243,156,18,0.3))' : 'rgba(0,0,0,0.3)'};
        border-radius:12px;
        border:2px solid ${isDefeated ? 'rgba(241,196,15,0.6)' : 'rgba(255,255,255,0.1)'};
        transition:all 0.3s;
        opacity:${isDefeated ? '1' : '0.4'};
        cursor:${isDefeated ? 'pointer' : 'default'};
        position:relative;
      " ${isDefeated ? `onmouseover="this.style.transform='scale(1.1)';this.style.borderColor='rgba(241,196,15,0.9)'" onmouseout="this.style.transform='scale(1)';this.style.borderColor='rgba(241,196,15,0.6)'"` : ''}>
        ${!isDefeated ? '<div style="position:absolute;top:8px;right:8px;font-size:14px;">ğŸ”’</div>' : ''}
        <div style="font-size:${isDefeated ? '36px' : '20px'};line-height:1;filter:${isDefeated ? 'none' : 'grayscale(100%) brightness(0.5)'};">${boss.emoji}</div>
      </div>
    `;
  }).join('');
}

/**
 * Compte le nombre de boss vaincus
 */
function getDefeatedBossesCount() {
  if(!gameData.bossesDefeated) return 0;
  return Object.values(gameData.bossesDefeated).filter(defeated => defeated).length;
}

/**
 * Affiche la sagesse d'un boss dÃ©verrouillÃ©
 */
function showBossWisdom(bossId) {
  if(!gameData.bossesDefeated || !gameData.bossesDefeated[bossId]) {
    msg('ğŸ”’ ' + t('treasure.boss_wisdom_locked'));
    return;
  }
  
  const bossTranslations = t(`bosses.${bossId}`);
  if(!bossTranslations) {
      return;
  }
  
  const wisdomDiv = document.createElement('div');
  wisdomDiv.id = 'bossWisdomDisplay';
  wisdomDiv.style.cssText = `
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90%;
    max-width: 500px;
    max-height: 85vh;
    background: linear-gradient(135deg, rgba(52,73,94,0.98) 0%, rgba(44,62,80,0.98) 100%);
    color: white;
    padding: 30px;
    border-radius: 20px;
    box-shadow: 0 10px 50px rgba(0,0,0,0.7), 0 0 30px rgba(241,196,15,0.3);
    z-index: 600;
    overflow-y: auto;
    border: 3px solid rgba(241,196,15,0.5);
  `;
  
  wisdomDiv.innerHTML = `
    <button onclick="this.parentElement.remove()" style="position:absolute;top:10px;right:10px;background:rgba(0,0,0,0.5);color:white;border:none;border-radius:50%;width:35px;height:35px;font-size:20px;cursor:pointer;font-weight:bold;line-height:1;">âœ•</button>
    
    <div style="text-align:center;margin-bottom:20px;">
      <h2 style="margin:0 0 10px 0;font-size:26px;">${bossTranslations.name}</h2>
      <div style="font-size:48px;margin:15px 0;">${getBossEmoji(bossId)}</div>
    </div>
    
    <div style="background:rgba(241,196,15,0.15);padding:20px;border-radius:12px;border:2px solid rgba(241,196,15,0.3);margin-bottom:20px;">
      <h3 style="margin:0 0 15px 0;text-align:center;color:#f1c40f;">ğŸ“œ ${t('treasure.boss_wisdom_philosophy')}</h3>
      <p style="line-height:1.8;font-size:14px;text-align:justify;margin:0;">
        ${bossTranslations.wisdom}
      </p>
    </div>
    
    <div style="background:rgba(46,204,113,0.15);padding:15px;border-radius:10px;border:2px solid rgba(46,204,113,0.3);">
      <h4 style="margin:0 0 10px 0;text-align:center;color:#2ecc71;">ğŸ’ ${t('treasure.boss_wisdom_victory')}</h4>
      <p style="line-height:1.6;font-size:13px;text-align:center;margin:0;">
        ${bossTranslations.defeated}
      </p>
    </div>
    
    <div style="text-align:center;margin-top:20px;">
      <button onclick="this.parentElement.parentElement.remove()" style="
        padding:12px 30px;
        background:linear-gradient(135deg, #f1c40f, #f39c12);
        color:#2c3e50;
        border:none;
        border-radius:10px;
        font-size:14px;
        font-weight:bold;
        cursor:pointer;
        box-shadow:0 4px 6px rgba(0,0,0,0.3);
        transition:transform 0.2s;
      " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
        âœ¨ ${t('treasure.boss_wisdom_close')}
      </button>
    </div>
  `;
  
  document.getElementById('gameContainer').appendChild(wisdomDiv);
}

/**
 * RÃ©cupÃ¨re l'emoji d'un boss
 */
function getBossEmoji(bossId) {
  const emojis = {
    spider: 'ğŸ•·ï¸',
    flying_snake: 'ğŸ',
    crazy_chicken: 'ğŸ”',
    grim_reaper: 'ğŸ’€',
    wall: 'ğŸ§±',
    dark_cloud: 'â˜ï¸',
    black_raven: 'ğŸ¦â€â¬›'
  };
  return emojis[bossId] || 'ğŸ‘¹';
}

/**
 * Calcule le pourcentage de progression vers le prochain verset (0-100%)
 */
function getInfiniteProgressPercent() {
  if (!infiniteCloudsCleared || infiniteCloudsCleared === 0) return 0;
  const progressInCycle = infiniteCloudsCleared % 100;
  return progressInCycle;
}

/**
 * Calcule combien de nuages restent avant le prochain verset
 */
function getNextVerseIn() {
  if (!infiniteCloudsCleared || infiniteCloudsCleared === 0) return t('treasure.xp_clouds', {count: 100});
  const progressInCycle = infiniteCloudsCleared % 100;
  const remaining = 100 - progressInCycle;
  return t('treasure.xp_clouds', {count: remaining});
}

function showStats() {
  const statsDiv = document.createElement('div');
  statsDiv.id = 'statsDisplay';
  statsDiv.style.cssText = `
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90%;
    max-width: 420px;
    max-height: 85vh;
    background: linear-gradient(135deg, rgba(52,152,219,0.98) 0%, rgba(41,128,185,0.98) 100%);
    color: white;
    padding: 60px 30px 30px 30px;
    border-radius: 20px;
    box-shadow: 0 10px 50px rgba(0,0,0,0.5);
    z-index: 500;
    overflow-y: auto;
  `;
  
  const formatTime = (seconds) => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    return hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;
  };
  
  const accuracy = gameData.stats.totalShots > 0 
    ? ((gameData.stats.totalHits / gameData.stats.totalShots) * 100).toFixed(1)
    : 0;
  
  // Calculer progression des bonus
  const bonusCompleted = gameData.bonusLevels?.completed?.filter(b => b).length || 0;
  const bonusTotalScore = gameData.bonusLevels?.bestScores?.reduce((a,b) => a+b, 0) || 0;
  
  statsDiv.innerHTML = `
    <button onclick="this.parentElement.remove()" style="
      position: sticky;
      top: 0;
      right: 10px;
      float: right;
      background: rgba(231, 76, 60, 0.9);
      color: white;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 12px;
      width: 45px;
      height: 45px;
      font-size: 24px;
      cursor: pointer;
      font-weight: bold;
      line-height: 1;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      transition: all 0.2s ease;
      margin-bottom: -45px;
    " onmouseover="this.style.background='rgba(231, 76, 60, 1)'; this.style.transform='scale(1.1)'" onmouseout="this.style.background='rgba(231, 76, 60, 0.9)'; this.style.transform='scale(1)'">âœ•</button>
    <h2 style="text-align:center;margin-bottom:20px;font-size:24px;clear:both;">${t('treasure.title')}</h2>
    
    <div style="background:linear-gradient(135deg, rgba(231,76,60,0.2), rgba(241,196,15,0.2));padding:15px;border-radius:10px;margin-bottom:15px;border:2px solid rgba(231,76,60,0.3);">
      <h3 style="margin-top:0;text-align:center;">ğŸ‘¤ ${t('treasure.my_profile')}</h3>
      <p style="margin:8px 0;text-align:center;"><strong>ğŸ® ${t('treasure.nickname')}:</strong> ${localStorage.getItem('dovePlayerNickname') || playerProfile.nickname || t('treasure.not_set')}</p>
      <p style="margin:8px 0;text-align:center;"><strong>ğŸ“§ ${t('treasure.email')}:</strong> ${localStorage.getItem('dovePlayerEmail') || playerProfile.email || t('treasure.not_set')}</p>
      <p style="margin:8px 0;text-align:center;"><strong>â˜ï¸ ${t('treasure.cloud_status')}:</strong> ${localStorage.getItem('dovePlayerNickname') && localStorage.getItem('dovePlayerEmail') ? 'âœ… ' + t('treasure.connected') : 'ğŸ”’ ' + t('treasure.disconnected')}</p>
      <p style="margin:8px 0;text-align:center;"><strong>ğŸ† ${t('treasure.best_score')}:</strong> ${playerProfile.bestScore.toLocaleString()}</p>
      <p style="margin:8px 0;text-align:center;"><strong>ğŸ¯ ${t('treasure.max_level')}:</strong> ${playerProfile.highestLevel}</p>
      ${playerProfile.lastPlayed ? `<p style="margin:8px 0;text-align:center;font-size:12px;opacity:0.8;">${t('treasure.last_game')}: ${new Date(playerProfile.lastPlayed).toLocaleDateString(currentLang === 'en' ? 'en-US' : 'fr-FR')}</p>` : ''}
      <div style="text-align:center;margin-top:12px;">
        <button onclick="document.getElementById('statsDisplay').remove(); showSupabaseSave();" style="
          padding:10px 20px;
          background:linear-gradient(135deg, #667eea, #764ba2);
          color:white;
          border:none;
          border-radius:8px;
          font-size:13px;
          font-weight:bold;
          cursor:pointer;
          box-shadow:0 4px 6px rgba(0,0,0,0.2);
          transition:transform 0.2s;
        " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
          ${localStorage.getItem('dovePlayerNickname') && localStorage.getItem('dovePlayerEmail') ? t('treasure.cloud_manage') : t('treasure.cloud_connect')}
        </button>
      </div>
    </div>
    
    <!-- Onglets de Conseils de Vie -->
    <div style="margin-bottom:20px;">
      <div style="display:flex;gap:8px;margin-bottom:15px;flex-wrap:wrap;justify-content:center;">
        <button onclick="showLifeTip('faith')" style="padding:8px 15px;background:rgba(46,204,113,0.3);color:white;border:2px solid rgba(46,204,113,0.5);border-radius:8px;cursor:pointer;font-weight:bold;font-size:12px;transition:all 0.2s;" onmouseover="this.style.background='rgba(46,204,113,0.5)'" onmouseout="this.style.background='rgba(46,204,113,0.3)'">${t('treasure.life_tips_faith')}</button>
        <button onclick="showLifeTip('courage')" style="padding:8px 15px;background:rgba(241,196,15,0.3);color:white;border:2px solid rgba(241,196,15,0.5);border-radius:8px;cursor:pointer;font-weight:bold;font-size:12px;transition:all 0.2s;" onmouseover="this.style.background='rgba(241,196,15,0.5)'" onmouseout="this.style.background='rgba(241,196,15,0.3)'">${t('treasure.life_tips_courage')}</button>
        <button onclick="showLifeTip('peace')" style="padding:8px 15px;background:rgba(52,152,219,0.3);color:white;border:2px solid rgba(52,152,219,0.5);border-radius:8px;cursor:pointer;font-weight:bold;font-size:12px;transition:all 0.2s;" onmouseover="this.style.background='rgba(52,152,219,0.5)'" onmouseout="this.style.background='rgba(52,152,219,0.3)'">${t('treasure.life_tips_peace')}</button>
        <button onclick="showLifeTip('love')" style="padding:8px 15px;background:rgba(231,76,60,0.3);color:white;border:2px solid rgba(231,76,60,0.5);border-radius:8px;cursor:pointer;font-weight:bold;font-size:12px;transition:all 0.2s;" onmouseover="this.style.background='rgba(231,76,60,0.5)'" onmouseout="this.style.background='rgba(231,76,60,0.3)'">${t('treasure.life_tips_love')}</button>
      </div>
      <div id="lifeTipContent" style="background:rgba(255,255,255,0.15);padding:20px;border-radius:10px;min-height:150px;">
        <p style="text-align:center;opacity:0.8;font-style:italic;">${t('treasure.life_tips_prompt')}</p>
      </div>
    </div>
    
    <div style="background:rgba(255,255,255,0.1);padding:15px;border-radius:10px;margin-bottom:15px;">
      <h3 style="margin-top:0;">${t('treasure.my_records')}</h3>
      <p style="margin:8px 0;"><strong>${t('treasure.best_score')}:</strong> ${gameData.highScore.toLocaleString()}</p>
      <p style="margin:8px 0;"><strong>${t('treasure.max_level')}:</strong> ${gameData.highestLevelReached}</p>
      <p style="margin:8px 0;"><strong>${t('treasure.star_stock')}:</strong> ${gameData.starStock || 0}</p>
    </div>
    
    <!-- Panneau des Chapitres GagnÃ©s -->
    <div style="background:linear-gradient(135deg, rgba(102,126,234,0.2), rgba(118,75,162,0.2));padding:15px;border-radius:10px;margin-bottom:15px;border:2px solid rgba(102,126,234,0.3);">
      <h3 style="margin-top:0;text-align:center;">${t('treasure.chapters_conquered')}</h3>
      <div style="display:flex;flex-wrap:wrap;gap:10px;margin-top:15px;justify-content:center;">
        ${generateChapterIcons()}
      </div>
      <p style="text-align:center;margin-top:15px;font-size:14px;opacity:0.9;">
        <strong>${getCompletedChaptersCount()}/14</strong> ${t('treasure.chapters_completed')}
      </p>
    </div>
    
    <!-- Panneau des Sagesses des Boss -->
    <div style="background:linear-gradient(135deg, rgba(155,89,182,0.2), rgba(142,68,173,0.2));padding:15px;border-radius:10px;margin-bottom:15px;border:2px solid rgba(155,89,182,0.3);">
      <h3 style="margin-top:0;text-align:center;">ğŸ“š ${t('treasure.boss_wisdom_title')}</h3>
      <p style="text-align:center;font-size:12px;opacity:0.9;margin-bottom:15px;">${t('treasure.boss_wisdom_subtitle')}</p>
      <div style="display:flex;flex-wrap:wrap;gap:12px;margin-top:15px;justify-content:center;">
        ${generateBossWisdomIcons()}
      </div>
      <p style="text-align:center;margin-top:15px;font-size:14px;opacity:0.9;">
        <strong>${getDefeatedBossesCount()}/7</strong> ${t('treasure.boss_wisdom_collected')}
      </p>
    </div>
    
    <!-- Barre de Progression XP Mode Infini -->
    <div style="background:linear-gradient(135deg, rgba(212,175,55,0.2), rgba(201,169,97,0.2));padding:15px;border-radius:10px;margin-bottom:15px;border:2px solid rgba(212,175,55,0.4);">
      <h3 style="margin-top:0;text-align:center;">${t('treasure.infinite_progress')}</h3>
      <p style="text-align:center;margin:10px 0;font-size:13px;opacity:0.9;">
        ${t('treasure.verse_collection')}
      </p>
      <div style="margin:15px 0;">
        <div style="display:flex;justify-content:space-between;margin-bottom:8px;font-size:13px;">
          <span>${t('treasure.xp_clouds', {count: infiniteCloudsCleared || 0})}</span>
          <span>${t('treasure.next_verse', {count: getNextVerseIn()})}</span>
        </div>
        <div style="
          background:rgba(0,0,0,0.3);
          border-radius:20px;
          height:20px;
          overflow:hidden;
          border:2px solid rgba(212,175,55,0.5);
        ">
          <div style="
            background:linear-gradient(90deg, #d4af37 0%, #f1c40f 100%);
            height:100%;
            width:${getInfiniteProgressPercent()}%;
            border-radius:18px;
            transition:width 0.3s;
            box-shadow:0 0 10px rgba(212,175,55,0.6);
          "></div>
        </div>
      </div>
      <p style="text-align:center;margin-top:12px;font-size:14px;">
        ${t('treasure.verses_collected', {count: Math.floor((infiniteCloudsCleared || 0) / 100)})}
      </p>
    </div>
    
    ${gameData.lastPlayed ? `
      <p style="text-align:center;opacity:0.8;font-size:12px;margin-bottom:15px;">
        ${t('treasure.last_played')}: ${new Date(gameData.lastPlayed).toLocaleDateString(currentLang === 'en' ? 'en-US' : 'fr-FR')}
      </p>
    ` : ''}
    
    <div style="background:linear-gradient(135deg, rgba(52,152,219,0.2), rgba(155,89,182,0.2));padding:15px;border-radius:10px;margin-bottom:20px;border:2px solid rgba(52,152,219,0.3);">
      <h3 style="margin-top:0;text-align:center;">${t('treasure.creator')}</h3>
      <p style="margin:8px 0;text-align:center;"><strong>${t('treasure.creator_name')}</strong></p>
      <p style="margin:8px 0;text-align:center;font-size:13px;opacity:0.9;">${t('treasure.creator_bio')}</p>
      <p style="margin:8px 0;text-align:center;font-size:12px;opacity:0.8;">${t('treasure.audiomack')}: <strong>emmanuelpayet888</strong></p>
      <p style="margin:6px 0;text-align:center;font-size:11px;opacity:0.7;">${t('treasure.creator_message')}</p>
      <div style="text-align:center;margin-top:12px;">
        <a href="./public/emmanuel-artist-module.html" target="_blank" style="
          display:inline-block;
          padding:10px 20px;
          background:linear-gradient(135deg, #3498db, #9b59b6);
          color:white;
          text-decoration:none;
          border-radius:8px;
          font-size:13px;
          font-weight:bold;
          box-shadow:0 4px 6px rgba(0,0,0,0.2);
          transition:transform 0.2s;
        " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
          ${t('treasure.discover_artist')}
        </a>
      </div>
    </div>
    
    <div style="background:linear-gradient(135deg, rgba(231,76,60,0.15), rgba(241,196,15,0.15));padding:18px;border-radius:10px;margin-bottom:20px;border:2px solid rgba(231,76,60,0.3);text-align:center;">
      <h3 style="margin-top:0;color:#e74c3c;">ğŸ’¬ ${t('treasure.testimonies_title')}</h3>
      <p style="margin:10px 0;font-size:13px;opacity:0.9;">${t('treasure.testimonies_description')}</p>
      <button onclick="document.getElementById('statsDisplay').remove(); showTestimonies();" style="
        padding:12px 24px;
        background:linear-gradient(135deg, #e74c3c, #f39c12);
        color:white;
        border:none;
        border-radius:10px;
        font-size:14px;
        font-weight:bold;
        cursor:pointer;
        box-shadow:0 4px 6px rgba(0,0,0,0.2);
        transition:transform 0.2s;
      " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
        ğŸ’ ${t('treasure.read_testimonies')}
      </button>
    </div>
    
    <div style="display:flex;gap:10px;justify-content:center;flex-wrap:wrap;">
      <button onclick="this.parentElement.parentElement.remove()" style="
        padding:12px 24px;
        background:#27ae60;
        color:white;
        border:none;
        border-radius:10px;
        font-size:16px;
        font-weight:bold;
        cursor:pointer;
      ">âœ… ${t('buttons.close')}</button>
      
      <button onclick="manualCloudSave()" style="
        padding:12px 24px;
        background:#3498db;
        color:white;
        border:none;
        border-radius:10px;
        font-size:16px;
        font-weight:bold;
        cursor:pointer;
      ">â˜ï¸ ${t('treasure.save_cloud')}</button>
      
      <button onclick="exportGameData()" style="
        padding:12px 24px;
        background:#e74c3c;
        color:white;
        border:none;
        border-radius:10px;
        font-size:16px;
        font-weight:bold;
        cursor:pointer;
      ">ğŸ† ${t('treasure.share_score')}</button>
    </div>
  `;
  
  document.getElementById('gameContainer').appendChild(statsDiv);
}

// Sauvegarde manuelle vers le cloud
async function manualCloudSave() {
  const nickname = localStorage.getItem('dovePlayerNickname');
  const email = localStorage.getItem('dovePlayerEmail');
  
  if (!nickname || !email) {
    showPopup(t('popups.not_connected'), 'â˜ï¸', 'error');
    return;
  }
  
  // VÃ©rifier qu'on a des donnÃ©es valides Ã  sauvegarder
  const hasValidData = gameData.highScore > 0 || gameData.highestLevelReached > 1;
  if (!hasValidData) {
    showPopup(t('popups.no_data_to_save'), 'â˜ï¸', 'warning');
    return;
  }
  
  showPopup(t('popups.saving'), 'â˜ï¸', 'info');
  
  try {
    // Initialiser Supabase
    if (typeof initSupabaseDove === 'function') {
      await initSupabaseDove();
    }
    
    // Sauvegarder avec syncDovePlayerData
    if (typeof syncDovePlayerData === 'function') {
      const result = await syncDovePlayerData(nickname, email, gameData);
      
      if (result.success) {
              showPopup(
          'âœ… Sauvegarde rÃ©ussie !\n\n' +
          `Score: ${gameData.highScore}\n` +
          `Niveau: ${gameData.highestLevelReached}\n` +
          `â­ Ã‰toiles: ${gameData.starStock}\n` +
          `â˜ï¸ Nuages: ${gameData.totalCloudsDestroyed}`,
          'â˜ï¸',
          'success'
        );
      } else {
              showPopup(t('popups.save_failed').replace('{error}', result.error), 'â˜ï¸', 'error');
      }
    } else {
      throw new Error('Fonction syncDovePlayerData non disponible');
    }
  } catch (error) {
      showPopup(t('popups.save_error').replace('{error}', error.message), 'â˜ï¸', 'error');
  }
}

// Sauvegarde automatique dans le cloud aprÃ¨s un nouveau record
async function autoSaveToCloud() {
  const nickname = localStorage.getItem('dovePlayerNickname');
  const email = localStorage.getItem('dovePlayerEmail');
  
  if (!nickname || !email) return;
  
  
  try {
    if (typeof initSupabaseDove === 'function') {
      await initSupabaseDove();
    }
    
    if (typeof syncDovePlayerData === 'function') {
      const result = await syncDovePlayerData(nickname, email, gameData);
      
      if (result.success) {
              // Afficher une notification discrÃ¨te
        showMessage(t('powerups.record_saved'), 2000);
      }
    }
  } catch (error) {
    }
}

// ============================================
// â˜ï¸ğŸ’¾ SYSTÃˆME DE SAUVEGARDE SIMPLIFIÃ‰
// ============================================

// Afficher le statut de connexion et permettre de se connecter
function showSupabaseSave() {
  const nickname = localStorage.getItem('dovePlayerNickname');
  const email = localStorage.getItem('dovePlayerEmail');
  const isConnected = nickname && email;
  
  const statusDiv = document.createElement('div');
  statusDiv.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.85);
    z-index: 999;
    overflow-y: auto;
    padding: 20px;
    box-sizing: border-box;
    display: flex;
    align-items: center;
    justify-content: center;
  `;
  
  statusDiv.innerHTML = `
    <div style="
      max-width: 500px;
      width: 100%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 30px;
      border-radius: 20px;
      color: white;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
      position: relative;
    ">
      <button onclick="this.parentElement.parentElement.remove()" style="
        position: absolute;
        top: 15px;
        right: 15px;
        background: rgba(0,0,0,0.3);
        color: white;
        border: none;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        font-size: 24px;
        cursor: pointer;
        font-weight: bold;
        line-height: 1;
        transition: all 0.3s;
      " onmouseover="this.style.background='rgba(231,76,60,0.8)'" onmouseout="this.style.background='rgba(0,0,0,0.3)'">âœ•</button>
      
      <div style="text-align: center; margin-bottom: 25px;">
        <div style="font-size: 60px; margin-bottom: 15px;">${isConnected ? 'âœ…â˜ï¸' : 'ğŸ”’'}</div>
        <h2 style="margin: 0; font-size: 28px; text-shadow: 0 2px 4px rgba(0,0,0,0.3);">
          ${isConnected ? 'ConnectÃ© au Cloud' : 'Connexion Cloud'}
        </h2>
        <p style="margin: 10px 0 0 0; opacity: 0.9; font-size: 14px;">
          ${isConnected ? `ConnectÃ© en tant que <strong>${nickname}</strong>` : 'Sauvegarde automatique dÃ©sactivÃ©e'}
        </p>
      </div>
      
      <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 15px; margin-bottom: 20px; backdrop-filter: blur(10px);">
        <h3 style="margin: 0 0 15px 0; font-size: 18px;">${t('powerups.save_system')}</h3>
        <ul style="margin: 0; padding-left: 20px; line-height: 1.8; font-size: 14px;">
          <li>ğŸ’¾ <strong>Locale</strong> : Automatique Ã  chaque niveau</li>
          <li>â˜ï¸ <strong>Cloud</strong> : ${isConnected ? 'Automatique si connectÃ©' : 'NÃ©cessite connexion'}</li>
          <li>ğŸ”„ <strong>Sync</strong> : Temps rÃ©el avec Supabase</li>
        </ul>
      </div>
      
      ${isConnected ? `
        <div style="background: rgba(46,204,113,0.3); padding: 15px; border-radius: 15px; margin-bottom: 20px; border: 2px solid rgba(46,204,113,0.5); text-align: center;">
          <div style="font-size: 14px;">
            <strong>âœ… Sauvegarde cloud activÃ©e</strong>
            <p style="margin: 10px 0 0 0; opacity: 0.9; font-size: 13px;">
              Ta progression est automatiquement sauvegardÃ©e en ligne<br>
              <strong>Email :</strong> ${email}
            </p>
          </div>
        </div>
        <button onclick="disconnectCloudSave()" style="
          width: 100%;
          padding: 15px 20px;
          background: linear-gradient(135deg, #e74c3c, #c0392b);
          color: white;
          border: none;
          border-radius: 12px;
          font-size: 16px;
          font-weight: bold;
          cursor: pointer;
          box-shadow: 0 4px 15px rgba(0,0,0,0.2);
          transition: all 0.3s;
        " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(0,0,0,0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(0,0,0,0.2)'">
          ğŸšª Se dÃ©connecter
        </button>
      ` : `
        <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 15px; margin-bottom: 20px;">
          <h3 style="margin: 0 0 15px 0; font-size: 18px;">ğŸ‘¤ Connexion Cloud</h3>
          <div style="margin-bottom: 12px;">
            <label style="display: block; margin-bottom: 5px; font-size: 14px; opacity: 0.9;">Pseudo</label>
            <input type="text" id="cloudNickname" placeholder="Ton pseudo" value="${nickname || ''}" style="
              width: 100%;
              padding: 12px;
              border: none;
              border-radius: 8px;
              font-size: 16px;
              box-sizing: border-box;
              background: rgba(255,255,255,0.9);
              color: #2c3e50;
            " />
          </div>
          <div>
            <label style="display: block; margin-bottom: 5px; font-size: 14px; opacity: 0.9;">Email</label>
            <input type="email" id="cloudEmail" placeholder="ton@email.com" style="
              width: 100%;
              padding: 12px;
              border: none;
              border-radius: 8px;
              font-size: 16px;
              box-sizing: border-box;
              background: rgba(255,255,255,0.9);
              color: #2c3e50;
            " />
          </div>
        </div>
        <button onclick="connectCloudSave()" style="
          width: 100%;
          padding: 15px 20px;
          background: linear-gradient(135deg, #2ecc71, #27ae60);
          color: white;
          border: none;
          border-radius: 12px;
          font-size: 16px;
          font-weight: bold;
          cursor: pointer;
          box-shadow: 0 4px 15px rgba(0,0,0,0.2);
          transition: all 0.3s;
        " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(0,0,0,0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(0,0,0,0.2)'">
          â˜ï¸ Se connecter
        </button>
      `}
      
      <div style="text-align: center; margin-top: 20px; opacity: 0.7; font-size: 12px;">
        Powered by Supabase ğŸš€
      </div>
    </div>
  `;
  
  document.getElementById('gameContainer').appendChild(statusDiv);
}

// Connexion au cloud
async function connectCloudSave() {
  const nickname = document.getElementById('cloudNickname').value.trim();
  const email = document.getElementById('cloudEmail').value.trim();
  
  if (!nickname || !email) {
    showPopup(t('popups.enter_nickname_email'), 'âš ï¸', 'warning');
    return;
  }
  
  // Valider l'email
  if (!email.includes('@')) {
    showPopup(t('popups.invalid_email'), 'ğŸ“§', 'error');
    return;
  }
  
  try {
    // Sauvegarder les identifiants temporairement
    const tempNickname = nickname;
    const tempEmail = email;
    
    // Initialiser Supabase
    if (typeof initSupabaseDove === 'function') {
      await initSupabaseDove();
    }
    
    // Charger les donnÃ©es cloud pour comparaison
      if (typeof loadDovePlayerData === 'function') {
      const cloudData = await loadDovePlayerData(tempNickname);
      
      if (cloudData.success && cloudData.progress) {
        const cloudScore = cloudData.progress.highScore || 0;
        const cloudLevel = cloudData.progress.highestLevelReached || 1;
        const localScore = gameData.highScore;
        const localLevel = gameData.highestLevelReached;
        
        const cloudHasData = cloudScore > 0 || cloudLevel > 1;
        const localHasData = localScore > 0 || localLevel > 1;
        const localIsBetter = localScore > cloudScore || localLevel > cloudLevel;
        
        // Si conflit : local et cloud ont tous les deux des donnÃ©es diffÃ©rentes
        if (cloudHasData && localHasData && localIsBetter) {
          const choice = confirm(
            `${t('popups.data_conflict')}\n\n` +
            `â˜ï¸ Cloud: Score ${cloudScore}, Niveau ${cloudLevel}\n` +
            `ğŸ’¾ Local: Score ${localScore}, Niveau ${localLevel}\n\n` +
            `Tes donnÃ©es locales sont meilleures !\n\n` +
            `OK = Garder LOCAL et Ã©craser le cloud\n` +
            `Annuler = Garder CLOUD et Ã©craser le local`
          );
          
          if (choice) {
            // Garder le local, envoyer au cloud
                      localStorage.setItem('dovePlayerNickname', tempNickname);
            localStorage.setItem('dovePlayerEmail', tempEmail);
            await autoSaveToCloud();
            showPopup(t('popups.connected_local_saved'), 'â˜ï¸', 'success');
          } else {
            // Garder le cloud, Ã©craser le local
                      localStorage.setItem('dovePlayerNickname', tempNickname);
            localStorage.setItem('dovePlayerEmail', tempEmail);
            await restoreFromCloudIfNeeded();
            showPopup(t('popups.connected_cloud_restored'), 'â˜ï¸', 'success');
          }
        } else {
          // Pas de conflit : synchronisation automatique
          localStorage.setItem('dovePlayerNickname', tempNickname);
          localStorage.setItem('dovePlayerEmail', tempEmail);
          await restoreFromCloudIfNeeded();
          showPopup(t('popups.connected_success'), 'â˜ï¸', 'success');
        }
      } else {
        // Pas de donnÃ©es cloud, juste se connecter
        localStorage.setItem('dovePlayerNickname', tempNickname);
        localStorage.setItem('dovePlayerEmail', tempEmail);
        await restoreFromCloudIfNeeded();
        showPopup(t('popups.connected_success'), 'â˜ï¸', 'success');
      }
    }
    
    // Fermer la modal
    const modal = document.querySelector('[style*="position: fixed"]');
    if (modal) modal.remove();
  } catch (error) {
      showPopup(`${t('popups.connection_error')}:\n${error.message}`, 'âš ï¸', 'error');
  }
}

// DÃ©connexion du cloud
function disconnectCloudSave() {
  if (confirm('ğŸ”’ Se dÃ©connecter de la sauvegarde cloud ?\n\nLa sauvegarde locale continuera de fonctionner.')) {
    localStorage.removeItem('dovePlayerNickname');
    localStorage.removeItem('dovePlayerEmail');
    showPopup('\u2705 D\u00e9connect\u00e9 avec succ\u00e8s !\n\nSauvegarde cloud d\u00e9sactiv\u00e9e.', '\ud83d\udeaa', 'info');
    document.querySelector('[style*="position: fixed"]').remove();
  }
}

// Sauvegarde automatique vers le cloud (si connectÃ©)
async function autoSaveToCloud() {
  const nickname = localStorage.getItem('dovePlayerNickname');
  const email = localStorage.getItem('dovePlayerEmail');
  
  // VÃ©rifier si connectÃ©
  if (!nickname || !email) {
    return;
  }
  
  try {
    // Initialiser Supabase si nÃ©cessaire
    if (typeof initSupabaseDove === 'function') {
      await initSupabaseDove();
    }
    
    // Sauvegarder avec syncDovePlayerData
    const result = await syncDovePlayerData(nickname, email, gameData);
    
    if (result.success) {
        } else {
        }
  } catch (error) {
    }
}

// Raccourci clavier pour afficher les stats (Ctrl+S ou Cmd+S)
document.addEventListener('keydown', (e) => {
  if ((e.ctrlKey || e.metaKey) && e.key === 's') {
    e.preventDefault();
    showStats();
  }
  
  /* TOUCHES TEST DÃ‰SACTIVÃ‰ES
  // Test : T pour tester le chapitre 14
  if (e.key === 't' || e.key === 'T') {
    testChapter14();
  }
  
  // Test : Y pour tester le chapitre 13
  if (e.key === 'y' || e.key === 'Y') {
    testChapter13();
  }
  
  // Test : V pour tester le verset mode infini
  if (e.key === 'v' || e.key === 'V') {
    testInfiniteVerse();
  }
  
  // Test : N pour ajouter +47 nuages (sans points)
  if (e.key === 'n' || e.key === 'N') {
    addTestClouds();
  }
  
  // Test : K pour tester changement de niveau
  if (e.key === 'k' || e.key === 'K') {
    testLevelChange();
  }
  
  // Test : + pour tester le menu victoire boss
  if (e.key === '+' || e.key === '=') {
    testBossVictoryMenu();
  }
  
  // Retour : R pour restaurer
  if (e.key === 'r' || e.key === 'R') {
    restoreBeforeTest();
  }
  */
});

// ğŸ§ª Fonction de test pour changement de niveau
function testLevelChange() {
  // Simuler qu'on est Ã  50 nuages (juste avant le niveau 2)
  gameData.totalCloudsDestroyed = 50;
  score = 5000;
  level = 1;
  
  // Mettre Ã  jour l'affichage
  if(document.getElementById('clouds')) document.getElementById('clouds').textContent = gameData.totalCloudsDestroyed;
  if(document.getElementById('score')) document.getElementById('score').textContent = score;
  if(document.getElementById('level')) document.getElementById('level').textContent = level;
  
  msg('ğŸ§ª Test: 50 nuages - DÃ©truisez 1 nuage pour niveau 2!');
}

// ğŸ§ª Fonction de test pour le menu victoire boss
function testBossVictoryMenu() {
  // Liste des boss disponibles
  const bosses = ['spider', 'flying_snake', 'crazy_chicken', 'grim_reaper', 'wall', 'dark_cloud', 'black_raven'];
  const randomBoss = bosses[Math.floor(Math.random() * bosses.length)];
  
  msg('ğŸ§ª Test: Menu victoire - ' + randomBoss);
  
  // Afficher le menu de victoire avec un boss alÃ©atoire
  showBossVictoryScreen(randomBoss, () => {
    msg('âœ… Menu fermÃ© - Test terminÃ©');
  });
}

// ğŸ§ª Fonction de test pour le verset mode infini
function testInfiniteVerse() {
  // Simuler qu'on est en mode infini avec 100 nuages
  infiniteCloudsCleared = 100;
  showInfiniteVerse('playing');
}

// ğŸ§ª Fonction de test pour le chapitre 13
function testChapter13() {
  if (confirm('ğŸ§ª TEST CHAPITRE 13\n\nTÃ©lÃ©porter Ã  750 nuages (juste avant le chapitre 13) ?\n\nOK = Oui\nAnnuler = Non')) {
    // TÃ©lÃ©porter au chapitre 13
    gameData.totalCloudsDestroyed = 750;
    score = 75000; // Score proportionnel
    gameData.highScore = Math.max(gameData.highScore, score);
    
    // Utiliser le systÃ¨me modulaire pour obtenir le niveau
    level = getCurrentLevel(750); // Devrait retourner 12
    gameData.highestLevelReached = Math.max(gameData.highestLevelReached, level);
    
      
    // Mettre Ã  jour l'affichage
    document.getElementById('score').textContent = score;
    document.getElementById('level').textContent = level;
    document.getElementById('clouds').textContent = gameData.totalCloudsDestroyed;
    
    // Sauvegarder
    saveGameData();
    
    showPopup(
      'ğŸ§ª TEST ACTIVÃ‰\n\n' +
      'ğŸ“ Position: 750 nuages (chapitre 12)\n' +
      'ğŸ¯ Objectif: 751 nuages (chapitre 13 - nuit Ã©toilÃ©e)\n' +
      'ğŸŒŒ DÃ©truisez 1 nuage pour voir la nuit !\n\n' +
      'Appuyez sur R pour restaurer',
      'ğŸ§ª',
      'info'
    );
  }
}

// ğŸ§ª Fonction de test pour le chapitre 14
function testChapter14() {
  if (confirm('ğŸ§ª TEST CHAPITRE 14\n\nTÃ©lÃ©porter Ã  980 nuages (proche de la fin) ?\n\nOK = Oui\nAnnuler = Non')) {
    // Sauvegarder l'Ã©tat actuel
    const savedState = {
      clouds: gameData.totalCloudsDestroyed,
      score: score,
      level: level
    };
      
    // TÃ©lÃ©porter au chapitre 14 (proche de la fin Ã  991)
    gameData.totalCloudsDestroyed = 980;
    score = 98000; // Score proportionnel
    gameData.highScore = Math.max(gameData.highScore, score);
    
    // Utiliser le systÃ¨me modulaire pour obtenir le niveau basÃ© sur les nuages
    level = getCurrentLevel(980); // Devrait retourner 14
    gameData.highestLevelReached = Math.max(gameData.highestLevelReached, level);
    
      
    // Mettre Ã  jour l'affichage
    document.getElementById('score').textContent = score;
    document.getElementById('level').textContent = level;
    document.getElementById('clouds').textContent = gameData.totalCloudsDestroyed;
    
    // Sauvegarder
    saveGameData();
    
    showPopup(
      'ğŸ§ª TEST ACTIVÃ‰\n\n' +
      'ğŸ“ Position: 980 nuages (chapitre 14)\n' +
      'ğŸ¯ Objectif: 991 nuages (victoire)\n' +
      'âš¡ Encore 11 nuages Ã  dÃ©truire !\n\n' +
      'Appuyez sur R pour restaurer',
      'ğŸ§ª',
      'info'
    );
  }
}

// ğŸ”„ Restaurer l'Ã©tat avant le test
function restoreBeforeTest() {
  if (confirm('ğŸ”„ Restaurer l\'Ã©tat avant le test ?\n\nCela va recharger la page.')) {
    location.reload();
  }
}

// ğŸ§ª Ajouter +47 nuages (sans points)
function addTestClouds() {
  const before = gameData.totalCloudsDestroyed;
  gameData.totalCloudsDestroyed += 47;
  
  // Mettre Ã  jour l'affichage
  if(document.getElementById('clouds')) {
    document.getElementById('clouds').textContent = gameData.totalCloudsDestroyed;
  }
  
  msg(`ğŸ§ª +47 nuages : ${before} â†’ ${gameData.totalCloudsDestroyed}`, 3000);
  
  // Sauvegarder
  saveGameData();
}

// ============================================
// ğŸ’ğŸ“– SYSTÃˆME DE NIVEAUX ET HISTOIRE
// ============================================

// DÃ©finition des chapitres de l'histoire
const STORY_CHAPTERS = {
  fr: [
    {
      id: 1,
      title: "L'Ã‰veil de la Colombe",
      intro: "Dans un monde plongÃ© dans les tÃ©nÃ¨bres, une petite colombe s'Ã©veille. Sa mission : rallumer la lumiÃ¨re de l'espoir.",
      outro: "Les premiers nuages se dissipent. L'espoir renaÃ®t doucement..."
    },
    {
      id: 2,
      title: "La TempÃªte Commence",
      intro: "Les nuages deviennent plus sombres. La pluie menace. Mais ta foi est plus forte.",
      outro: "Tu as traversÃ© la tempÃªte ! La lumiÃ¨re perce les nuages."
    },
    {
      id: 3,
      title: "L'Ascension Divine",
      intro: "Le ciel s'ouvre. Les dÃ©fis s'intensifient. Tes ailes se renforcent Ã  chaque bataille.",
      outro: "Tu t'Ã©lÃ¨ves au-dessus des difficultÃ©s ! Le soleil brille de nouveau."
    },
    {
      id: 4,
      title: "Le Souffle de l'Espoir",
      intro: "Les tÃ©nÃ¨bres rÃ©sistent, mais ton cÅ“ur rayonne. Chaque nuage dissipÃ© est une victoire.",
      outro: "L'espoir se rÃ©pand comme une douce brise. Continue ton vol !"
    },
    {
      id: 5,
      title: "La RÃ©vÃ©lation Finale",
      intro: "Le dernier voile de nuages se dresse devant toi. C'est l'heure de la victoire finale.",
      outro: "VICTOIRE ! Le Psaume 99.1 - La vie est une aventure extraordinaire !"
    }
  ],
  en: [
    {
      id: 1,
      title: "The Dove's Awakening",
      intro: "In a world plunged into darkness, a small dove awakens. Your mission: relight the light of hope.",
      outro: "The first clouds dissipate. Hope is slowly reborn..."
    },
    {
      id: 2,
      title: "The Storm Begins",
      intro: "The clouds grow darker. Rain threatens. But your faith is stronger.",
      outro: "You weathered the storm! Light pierces through the clouds."
    },
    {
      id: 3,
      title: "Divine Ascension",
      intro: "The sky opens. Challenges intensify. Your wings strengthen with each battle.",
      outro: "You rise above difficulties! The sun shines again."
    },
    {
      id: 4,
      title: "The Breath of Hope",
      intro: "Darkness resists, but your heart radiates. Each cloud cleared is a victory.",
      outro: "Hope spreads like a gentle breeze. Continue your flight!"
    },
    {
      id: 5,
      title: "The Final Revelation",
      intro: "The last veil of clouds stands before you. It's time for final victory.",
      outro: "VICTORY! Psalm 99.1 - Life is an extraordinary adventure!"
    }
  ]
  // Ajouter d'autres langues au besoin
};

// ============================================================================
// SYSTÃˆME DE RANGS DE MAÃTRISE (Affichage dans le score UI uniquement)
// ============================================================================
// Ces 8 rangs (CADET Ã  AILE DU CIEL) sont utilisÃ©s UNIQUEMENT pour afficher
// le titre de maÃ®trise du joueur dans l'interface de score en haut de l'Ã©cran.
// Ils Ã©voluent en fonction des nuages dÃ©truits et donnent un sentiment de 
// progression visuelle, mais ne dÃ©clenchent PAS de boucliers.
// 
// NE PAS CONFONDRE avec les 14 CHAPITRES du systÃ¨me modulaire (js/levels/)
// qui gÃ¨rent la vraie progression du jeu et affichent les boucliers.
// ============================================================================

const LEVELS_CONFIG = [
  // Rang 1: CADET - Premiers Vols (0-75 nuages)
  {
    id: 1,
    title: "CADET - Premiers Vols",
    icon: "ğŸ¯",
    threshold: 0,
    cloudsToPass: 75,
    cloudSpeed: { min: 0.4, max: 1.0 },
    cloudSpawnRate: 0.004,
    shootingClouds: 0.25,
    rainSpeed: { min: 3, max: 4.5 },
    powerUpRate: 0.0036,
    background: { top: '#87ceeb', bottom: '#b8d8f8' },
    difficulty: 'easy'
  },
  // Rang 2: APPRENTI PILOTE - En Formation (76-150 nuages)
  {
    id: 2,
    title: "APPRENTI PILOTE - En Formation",
    icon: "ğŸ›©ï¸",
    threshold: 76,
    cloudsToPass: 75,
    cloudSpeed: { min: 0.4, max: 1.03 },
    cloudSpawnRate: 0.005,
    shootingClouds: 0.35,
    rainSpeed: { min: 3.2, max: 4.8 },
    powerUpRate: 0.0039,
    background: { top: '#7fc8e8', bottom: '#afd8f8' },
    difficulty: 'easy'
  },
  // Rang 3: AVIATEUR - BaptÃªme du Ciel (151-250 nuages)
  {
    id: 3,
    title: "AVIATEUR - BaptÃªme du Ciel",
    icon: "âœˆï¸",
    threshold: 151,
    cloudsToPass: 100,
    cloudSpeed: { min: 0.4, max: 1.05 },
    cloudSpawnRate: 0.006,
    shootingClouds: 0.45,
    rainSpeed: { min: 3.5, max: 5 },
    powerUpRate: 0.0042,
    background: { top: '#75b8d8', bottom: '#a8c8e8' },
    difficulty: 'easy'
  },
  // Rang 4: PILOTE CONFIRMÃ‰ - Navigateur Aguerri (251-375 nuages)
  {
    id: 4,
    title: "PILOTE CONFIRMÃ‰ - Navigateur Aguerri",
    icon: "ğŸ§­",
    threshold: 251,
    cloudsToPass: 125,
    cloudSpeed: { min: 0.4, max: 1.08 },
    cloudSpawnRate: 0.007,
    shootingClouds: 0.55,
    rainSpeed: { min: 3.8, max: 5.3 },
    powerUpRate: 0.0045,
    background: { top: '#6da8c8', bottom: '#9fb8d8' },
    difficulty: 'medium'
  },
  // Rang 5: AS DES CIEUX - Virtuose AilÃ© (376-525 nuages)
  {
    id: 5,
    title: "AS DES CIEUX - Virtuose AilÃ©",
    icon: "ğŸ¦…",
    threshold: 376,
    cloudsToPass: 150,
    cloudSpeed: { min: 0.4, max: 1.10 },
    cloudSpawnRate: 0.008,
    shootingClouds: 0.62,
    rainSpeed: { min: 4, max: 5.5 },
    powerUpRate: 0.0048,
    background: { top: '#6298b8', bottom: '#95a8c8' },
    difficulty: 'medium'
  },
  // Rang 6: ESCADRON D'Ã‰LITE - Force AÃ©rienne (526-700 nuages)
  {
    id: 6,
    title: "ESCADRON D'Ã‰LITE - Force AÃ©rienne",
    icon: "âš¡",
    threshold: 526,
    cloudsToPass: 175,
    cloudSpeed: { min: 0.4, max: 1.13 },
    cloudSpawnRate: 0.009,
    shootingClouds: 0.68,
    rainSpeed: { min: 4.2, max: 5.8 },
    powerUpRate: 0.0048,
    background: { top: '#5a8fb8', bottom: '#8898b8' },
    difficulty: 'medium'
  },
  // Rang 7: COMMANDANT - Tacticien CÃ©leste (701-900 nuages)
  {
    id: 7,
    title: "COMMANDANT - Tacticien CÃ©leste",
    icon: "â­",
    threshold: 701,
    cloudsToPass: 200,
    cloudSpeed: { min: 0.4, max: 1.14 },
    cloudSpawnRate: 0.010,
    shootingClouds: 0.73,
    rainSpeed: { min: 4.5, max: 6 },
    powerUpRate: 0.0051,
    background: { top: '#5287a8', bottom: '#8090b0' },
    difficulty: 'hard'
  },
  // Rang 8: STRATÃˆGE DES NUÃ‰ES - MaÃ®tre Tactique (901-1125 nuages)
  {
    id: 8,
    title: "STRATÃˆGE DES NUÃ‰ES - MaÃ®tre Tactique",
    icon: "ğŸ²",
    threshold: 901,
    cloudsToPass: 225,
    cloudSpeed: { min: 0.4, max: 1.16 },
    cloudSpawnRate: 0.011,
    shootingClouds: 0.77,
    rainSpeed: { min: 4.8, max: 6.3 },
    powerUpRate: 0.0051,
    background: { top: '#4a7f98', bottom: '#7888a8' },
    difficulty: 'hard'
  },
  // Rang 9: VÃ‰TÃ‰RAN - ForgÃ© par les TempÃªtes (1126-1375 nuages)
  {
    id: 9,
    title: "VÃ‰TÃ‰RAN - ForgÃ© par les TempÃªtes",
    icon: "ğŸ–ï¸",
    threshold: 1126,
    cloudsToPass: 250,
    cloudSpeed: { min: 0.4, max: 1.19 },
    cloudSpawnRate: 0.012,
    shootingClouds: 0.80,
    rainSpeed: { min: 5, max: 6.5 },
    powerUpRate: 0.0054,
    background: { top: '#437788', bottom: '#7080a0' },
    difficulty: 'hard'
  },
  // Rang 10: HÃ‰ROS CÃ‰LESTE - Champion Reconnu (1376-1650 nuages)
  {
    id: 10,
    title: "HÃ‰ROS CÃ‰LESTE - Champion Reconnu",
    icon: "ğŸŒŸ",
    threshold: 1376,
    cloudsToPass: 275,
    cloudSpeed: { min: 0.4, max: 1.21 },
    cloudSpawnRate: 0.013,
    shootingClouds: 0.83,
    rainSpeed: { min: 5.2, max: 6.8 },
    powerUpRate: 0.0054,
    background: { top: '#3c6f78', bottom: '#687898' },
    difficulty: 'expert'
  },
  // Rang 11: LÃ‰GENDE - Mythe IncarnÃ© (1651-1975 nuages)
  {
    id: 11,
    title: "LÃ‰GENDE - Mythe IncarnÃ©",
    icon: "ğŸ†",
    threshold: 1651,
    cloudsToPass: 325,
    cloudSpeed: { min: 0.4, max: 1.24 },
    cloudSpawnRate: 0.014,
    shootingClouds: 0.86,
    rainSpeed: { min: 5.5, max: 7 },
    powerUpRate: 0.0057,
    background: { top: '#356778', bottom: '#607090' },
    difficulty: 'expert'
  },
  // Rang 12: CHAMPION Ã‰TERNEL - Gloire Immortelle (1976-2350 nuages)
  {
    id: 12,
    title: "CHAMPION Ã‰TERNEL - Gloire Immortelle",
    icon: "ğŸ’«",
    threshold: 1976,
    cloudsToPass: 375,
    cloudSpeed: { min: 0.4, max: 1.26 },
    cloudSpawnRate: 0.015,
    shootingClouds: 0.88,
    rainSpeed: { min: 5.8, max: 7.3 },
    powerUpRate: 0.0057,
    background: { top: '#2e5f68', bottom: '#586888' },
    difficulty: 'expert'
  },
  // Rang 13: MAÃTRE PILOTE - Symphonie AÃ©rienne (2351-2800 nuages)
  {
    id: 13,
    title: "MAÃTRE PILOTE - Symphonie AÃ©rienne",
    icon: "ğŸ‘‘",
    threshold: 2351,
    cloudsToPass: 450,
    cloudSpeed: { min: 0.4, max: 1.28 },
    cloudSpawnRate: 0.016,
    shootingClouds: 0.91,
    rainSpeed: { min: 6, max: 7.5 },
    powerUpRate: 0.0060,
    background: { top: '#275758', bottom: '#506080' },
    difficulty: 'legendary'
  },
  // Rang 14: AILE DU CIEL - Gardien Ã‰ternel (2801+ nuages)
  {
    id: 14,
    title: "AILE DU CIEL - Gardien Ã‰ternel",
    icon: "ğŸ•Šï¸",
    threshold: 2801,
    cloudsToPass: 999,
    cloudSpeed: { min: 0.4, max: 1.30 },
    cloudSpawnRate: 0.018,
    shootingClouds: 0.95,
    rainSpeed: { min: 6.5, max: 8 },
    powerUpRate: 0.0063,
    background: { top: '#1a4f58', bottom: '#485878' },
    difficulty: 'legendary'
  }
];

// Variables globales du systÃ¨me de rangs de maÃ®trise
let currentLevelIndex = 0;
let currentLevelConfig = LEVELS_CONFIG[0];
let totalScore = 0;
let cloudsInLevel = 0;
// isInfiniteMode est fourni par progression-system.js
let infiniteCloudsCleared = 0; // Compteur de nuages en mode infini
let bossSpawnedThisLevel = false; // Flag pour Ã©viter le spawn multiple du boss dans un niveau
let bossDefeatRewardsGiven = false; // Flag pour Ã©viter de donner plusieurs fois les rÃ©compenses du boss
let levelBeforeBoss = 1; // Niveau avant le spawn du boss pour Ã©viter de sauter des niveaux

function updateLevelBackground() {
  const bg = currentLevelConfig.background;
  document.getElementById('gameContainer').style.background = 
    `linear-gradient(180deg, ${bg.top} 0%, ${bg.bottom} 100%)`;
}

/**
 * Applique un fond de nuit Ã©toilÃ©e avec lune pleine pour les niveaux 13 et 14
 */
function applyNightSkyBackground(levelId) {
  const gameContainer = document.getElementById('gameContainer');
  const sun = document.getElementById('sun');
  
  if(levelId === 13) {
    // Niveau 13: Nuit Ã©toilÃ©e avec dÃ©but de lune
    gameContainer.style.background = 'linear-gradient(180deg, #0a0e27 0%, #1a1f3a 100%)';
    
    // Masquer le soleil
    if(sun) sun.style.display = 'none';
    
    // CrÃ©er des Ã©toiles si pas dÃ©jÃ  crÃ©Ã©es
    if(!document.getElementById('starfield')) {
      createStarfield();
    }
  } else if(levelId === 14) {
    // Niveau 14: Nuit profonde avec lune pleine
    gameContainer.style.background = 'linear-gradient(180deg, #050818 0%, #0f1429 100%)';
    
    // Masquer le soleil
    if(sun) sun.style.display = 'none';
    
    // CrÃ©er des Ã©toiles si pas dÃ©jÃ  crÃ©Ã©es
    if(!document.getElementById('starfield')) {
      createStarfield();
    }
    
    // Ajouter la lune pleine si pas dÃ©jÃ  crÃ©Ã©e
    if(!document.getElementById('fullMoon')) {
      createFullMoon();
    }
  }
}

/**
 * CrÃ©e un champ d'Ã©toiles en arriÃ¨re-plan
 */
function createStarfield() {
  const starfield = document.createElement('div');
  starfield.id = 'starfield';
  starfield.style.cssText = `
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1;
  `;
  
  // CrÃ©er 100 Ã©toiles alÃ©atoires
  for(let i = 0; i < 100; i++) {
    const star = document.createElement('div');
    star.style.cssText = `
      position: absolute;
      width: ${Math.random() * 3 + 1}px;
      height: ${Math.random() * 3 + 1}px;
      background: white;
      border-radius: 50%;
      top: ${Math.random() * 100}%;
      left: ${Math.random() * 100}%;
      opacity: ${Math.random() * 0.8 + 0.2};
      animation: twinkle ${Math.random() * 3 + 2}s infinite alternate;
    `;
    starfield.appendChild(star);
  }
  
  // Ajouter l'animation de scintillement
  if(!document.getElementById('starAnimation')) {
    const style = document.createElement('style');
    style.id = 'starAnimation';
    style.textContent = `
      @keyframes twinkle {
        0% { opacity: 0.2; }
        100% { opacity: 1; }
      }
    `;
    document.head.appendChild(style);
  }
  
  document.getElementById('gameContainer').appendChild(starfield);
}

/**
 * CrÃ©e une lune pleine dans le ciel
 */
function createFullMoon() {
  const moon = document.createElement('div');
  moon.id = 'fullMoon';
  moon.style.cssText = `
    position: absolute;
    top: 80px;
    right: 100px;
    width: 80px;
    height: 80px;
    background: radial-gradient(circle at 30% 30%, #fff9e6 0%, #f0e68c 40%, #daa520 100%);
    border-radius: 50%;
    box-shadow: 
      0 0 40px rgba(255,249,230,0.8),
      0 0 80px rgba(240,230,140,0.6),
      inset -10px -10px 20px rgba(0,0,0,0.1);
    pointer-events: none;
    z-index: 2;
  `;
  
  document.getElementById('gameContainer').appendChild(moon);
}

/**
 * Restaure le fond de jour normal et supprime les Ã©lÃ©ments de nuit
 */
function restoreDayBackground() {
  const gameContainer = document.getElementById('gameContainer');
  const sun = document.getElementById('sun');
  
  // Restaurer le fond bleu ciel normal
  gameContainer.style.background = 'linear-gradient(180deg, #87ceeb 0%, #b8d8f8 100%)';
  
  // RÃ©afficher le soleil
  if(sun) sun.style.display = 'block';
  
  // Supprimer les Ã©toiles
  const starfield = document.getElementById('starfield');
  if(starfield) {
    starfield.remove();
  }
  
  // Supprimer la lune
  const moon = document.getElementById('fullMoon');
  if(moon) {
    moon.remove();
  }
  
}

function startLevel(levelIndex) {
  currentLevelIndex = levelIndex;
  
  // Mode infini : on reste sur le dernier niveau (14)
  if (levelIndex >= LEVELS_CONFIG.length) {
    currentLevelConfig = LEVELS_CONFIG[LEVELS_CONFIG.length - 1];
    // Mode infini dÃ©tectÃ© automatiquement par isInfiniteMode(gameData.totalCloudsDestroyed)
  } else {
    currentLevelConfig = LEVELS_CONFIG[levelIndex];
  }
  
  cloudsInLevel = 0;
  bossSpawnedThisLevel = false; // Permettre le spawn du boss pour ce niveau

  // Mettre Ã  jour l'arriÃ¨re-plan
  updateLevelBackground();
  
  // RÃ©initialiser les Ã©lÃ©ments du jeu (mais PAS les power-ups actifs)
  bullets = [];
  clouds = [];
  rain = [];
  particles = [];
  powerUps = [];
  hearts = [];
  fallingPowerUps = [];
  cloudKillCount = 0;
  bossShootCount = 0;
  collectedStar = false;
  shockwaves = [];
  // umbrella, electric, multi restent actifs pour le niveau suivant
  
  // Activer la pluie dÃ©corative pour le niveau 7
  if (currentLevelConfig.id === 7) {
    decorativeRain = [];
    for (let i = 0; i < 50; i++) {
      decorativeRain.push(decorativeRainDrop());
    }
  } else {
    decorativeRain = [];
  }
  
  // Mettre Ã  jour le niveau affichÃ© dans l'UI
  level = currentLevelConfig.id;
  
  // Afficher l'Ã©cran d'introduction pour le niveau 1 OU si c'est une nouvelle partie
  const isFirstGame = gameData.totalCloudsDestroyed === 0;
  
  if (levelIndex === 0) {
    state = 'levelComplete';
    setTimeout(() => {
      // RÃ©cupÃ©rer message et verset depuis le systÃ¨me de traduction
      const levelMessage = getLevelMessage(currentLevelConfig.id);
      const levelVerse = getLevelVerse(currentLevelConfig.id);

      const levelUpDiv = document.createElement('div');
      levelUpDiv.id = 'levelUpScreen';
      levelUpDiv.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 400;
        padding: 20px;
        box-sizing: border-box;
        animation: fadeIn 0.5s ease-in;
      `;
      levelUpDiv.innerHTML = `
        <div onclick="this.parentElement.remove(); state = 'playing'; autoHideMenuOnStart(); setSun('happy');" style="
          width: 320px;
          min-height: 420px;
          background: linear-gradient(145deg, #ffffff 0%, #fafafa 100%);
          border: 1px solid rgba(0,0,0,0.08);
          border-radius: 32px;
          box-shadow: 
            0 20px 60px rgba(0,0,0,0.08),
            0 8px 20px rgba(0,0,0,0.04),
            inset 0 1px 0 rgba(255,255,255,0.9);
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          padding: 42px 32px;
          box-sizing: border-box;
          gap: 22px;
          cursor: pointer;
          transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
          position: relative;
        " onmouseover="
          this.style.transform='translateY(-4px)';
          this.style.boxShadow='0 25px 70px rgba(0,0,0,0.1), 0 10px 25px rgba(0,0,0,0.05), inset 0 1px 0 rgba(255,255,255,0.9)';
        " onmouseout="
          this.style.transform='translateY(0)';
          this.style.boxShadow='0 20px 60px rgba(0,0,0,0.08), 0 8px 20px rgba(0,0,0,0.04), inset 0 1px 0 rgba(255,255,255,0.9)';
        ">
          <!-- IcÃ´ne Colombe -->
          <div style="
            font-size: 64px;
            filter: drop-shadow(0 4px 12px rgba(0,0,0,0.08));
          ">ğŸ•Šï¸</div>
          
          <!-- Titre Bienvenue -->
          <h2 style="
            color: #1a1a1a;
            font-size: 26px;
            margin: 0;
            font-weight: 300;
            letter-spacing: -0.5px;
            text-align: center;
            line-height: 1.3;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            text-wrap: balance;
            max-width: 100%;
          ">
            ${t('messages.welcome')}
          </h2>
          
          <!-- Badge Niveau -->
          <div style="
            background: linear-gradient(135deg, #f8f8f8 0%, #f0f0f0 100%);
            color: #333;
            padding: 10px 28px;
            border-radius: 24px;
            font-weight: 600;
            font-size: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            letter-spacing: 0.5px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            border: 1px solid rgba(0,0,0,0.06);
          ">
            ${currentLevelConfig.icon} ${t('ui.level').toUpperCase()} ${currentLevelConfig.id}
          </div>
          
          <!-- Section Message -->
          <div style="display: flex; flex-direction: column; gap: 14px; width: 100%;">
            <h4 style="
              color: #2a2a2a;
              font-size: 18px;
              margin: 0;
              font-weight: 500;
              text-align: center;
              line-height: 1.4;
              letter-spacing: -0.2px;
              font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
              text-wrap: balance;
              max-width: 100%;
            ">
              ${t('level_titles.' + currentLevelConfig.id)}
            </h4>
            <p style="
              color: #666;
              font-size: 14px;
              line-height: 1.7;
              margin: 0;
              text-align: center;
              font-weight: 400;
              letter-spacing: 0;
              word-wrap: break-word;
              white-space: normal;
              font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
              text-wrap: balance;
              max-width: 100%;
            ">
              ${levelMessage}
            </p>
          </div>
          
          <!-- Verset -->
          <div style="
            background: #fafafa;
            padding: 20px;
            border-radius: 20px;
            border: 1px solid rgba(0,0,0,0.06);
            width: 100%;
            box-sizing: border-box;
          ">
            <p style="
              color: #444;
              font-size: 13px;
              font-style: italic;
              margin: 0 0 12px 0;
              line-height: 1.7;
              text-align: center;
              font-weight: 400;
              font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
              text-wrap: pretty;
              max-width: 100%;
            ">
              ${levelVerse.text}
            </p>
            <p style="
              color: #888;
              font-size: 11px;
              margin: 0;
              font-weight: 500;
              text-align: center;
              letter-spacing: 0.3px;
              font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            ">
              â€” ${levelVerse.reference}
            </p>
          </div>
        </div>
      `;
      document.getElementById('gameContainer').appendChild(levelUpDiv);
    }, 500);
  } else {
    state = 'playing';
    autoHideMenuOnStart();
    setSun('happy');
  }
}

function completeLevel() {
  state = 'levelComplete';
  const nextLevelIndex = currentLevelIndex + 1;
  
  if (nextLevelIndex >= LEVELS_CONFIG.length) {
    // VICTOIRE FINALE (991 nuages) !
    state = 'victory';
    msg(t('messages.victory'));
    setTimeout(() => {
      // Afficher un Ã©cran de victoire spÃ©cial
      const victoryDiv = document.createElement('div');
      victoryDiv.id = 'victoryScreen';
      victoryDiv.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, rgba(240,242,245,0.98) 0%, rgba(255,255,255,0.95) 100%);
        backdrop-filter: blur(20px);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 500;
        padding: 20px;
        box-sizing: border-box;
        animation: fadeIn 0.5s ease-in;
      `;
      victoryDiv.innerHTML = `
        <div style="max-width: 500px; text-align: center; background: rgba(255,255,255,0.8); padding: 40px 30px; border-radius: 30px; box-shadow: 0 20px 60px rgba(0,0,0,0.1), 0 0 0 1px rgba(255,255,255,0.5) inset; border: 2px solid rgba(255,255,255,0.8);">
          <div style="display: inline-block; padding: 12px 30px; background: linear-gradient(135deg, #e0e0e0 0%, #bdbdbd 100%); border-radius: 25px; margin-bottom: 25px; box-shadow: 0 8px 20px rgba(0,0,0,0.15);">
            <h1 style="color: #424242; font-size: 32px; margin: 0; font-weight: 800; letter-spacing: 2px; text-shadow: 0 1px 2px rgba(255,255,255,0.5);">
              ğŸ† VICTOIRE ğŸ†
            </h1>
          </div>
          <div style="background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%); padding: 20px; border-radius: 20px; margin-bottom: 25px;">
            <p style="color: #2c3e50; font-size: 14px; line-height: 1.8; margin: 0 0 20px 0; font-weight: 500;">
              ${t('messages.victory')}
            </p>
            <div style="display: flex; justify-content: space-around; gap: 15px;">
              <div style="flex: 1; background: rgba(255,255,255,0.7); padding: 15px; border-radius: 15px;">
                <div style="font-size: 28px; color: #667eea; font-weight: bold;">${score}</div>
                <div style="font-size: 12px; color: #6c757d; margin-top: 5px;">ğŸ¯ Score final</div>
              </div>
              <div style="flex: 1; background: rgba(255,255,255,0.7); padding: 15px; border-radius: 15px;">
                <div style="font-size: 28px; color: #667eea; font-weight: bold;">${cloudsCleared}</div>
                <div style="font-size: 12px; color: #6c757d; margin-top: 5px;">â˜ï¸ Nuages</div>
              </div>
            </div>
          </div>
          <button id="victoryBtn" style="
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            padding: 16px 50px;
            border-radius: 50px;
            color: white;
            font-size: 17px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 8px 25px rgba(102,126,234,0.4);
            transition: all 0.3s;
            letter-spacing: 1px;
            text-transform: uppercase;
          " onmouseover="this.style.transform='translateY(-3px) scale(1.02)'; this.style.boxShadow='0 12px 30px rgba(102,126,234,0.5)';"
             onmouseout="this.style.transform='translateY(0) scale(1)'; this.style.boxShadow='0 8px 25px rgba(102,126,234,0.4)';">
            ğŸ® ${t('buttons.infinite_mode') || 'Mode Infini'}
          </button>
        </div>
      `;
      document.getElementById('gameContainer').appendChild(victoryDiv);
      
      // Continuer en mode infini au clic
      document.getElementById('victoryBtn').addEventListener('click', () => {
        victoryDiv.remove();
        // Mode infini sera dÃ©tectÃ© automatiquement par isInfiniteMode(cloudCount)
        infiniteCloudsCleared = 0;
        currentLevelIndex = LEVELS_CONFIG.length; // Chapitre 15+
        state = 'playing';
        msg(t('powerups.infinite_mode'));
      });
    }, 2000);
  } else {
    // Passage au niveau suivant
    const nextConfig = LEVELS_CONFIG[nextLevelIndex];

    // RÃ©cupÃ©rer message et verset depuis le systÃ¨me de traduction
    const nextMessage = getLevelMessage(nextConfig.id);
    const nextVerse = getLevelVerse(nextConfig.id);

    // Afficher le message et le verset du nouveau niveau
    setTimeout(() => {
      const levelUpDiv = document.createElement('div');
      levelUpDiv.id = 'levelUpScreen';
      levelUpDiv.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 400;
        padding: 20px;
        box-sizing: border-box;
        animation: fadeIn 0.5s ease-in;
      `;
      levelUpDiv.innerHTML = `
        <div onclick="this.parentElement.remove(); playSound('levelup'); startLevel(${nextLevelIndex});" style="
          width: 300px;
          min-height: 400px;
          background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
          border: 3px solid #9e9e9e;
          border-bottom: 5px solid #9e9e9e;
          border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
          box-shadow: 0 15px 40px rgba(158,158,158,0.3), inset 0 2px 10px rgba(255,255,255,0.8);
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: space-between;
          padding: 38px 24px 32px 24px;
          box-sizing: border-box;
          cursor: pointer;
          transition: all 0.3s ease;
        " onmouseover="
          this.style.transform='scale(1.02)';
          this.style.boxShadow='0 20px 50px rgba(158,158,158,0.4), inset 0 2px 10px rgba(255,255,255,0.8)';
        " onmouseout="
          this.style.transform='scale(1)';
          this.style.boxShadow='0 15px 40px rgba(158,158,158,0.3), inset 0 2px 10px rgba(255,255,255,0.8)';
        ">
          <div style="
            background: linear-gradient(135deg, #e0e0e0 0%, #bdbdbd 100%);
            color: #424242;
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 15px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            text-shadow: 0 1px 2px rgba(255,255,255,0.5);
            letter-spacing: 1px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
          ">
            ${nextConfig.icon} ${t('ui.level').toUpperCase()} ${nextConfig.id}
          </div>
          <div style="display: flex; flex-direction: column; gap: 12px; width: 100%;">
            <h3 style="color: #2c3e50; font-size: 17px; margin: 0; font-weight: 500; text-align: center; line-height: 1.4; letter-spacing: 0.3px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;">
              ${t('level_titles.' + nextConfig.id)}
            </h3>
            <p style="color: #5a6c7d; font-size: 14px; line-height: 1.6; margin: 0; text-align: center; font-weight: 400; letter-spacing: 0.2px; word-wrap: break-word; white-space: normal; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;">
              ${nextMessage}
            </p>
          </div>
          <div style="background: rgba(102,126,234,0.08); padding: 16px; border-radius: 14px; border-left: 3px solid #667eea; width: 100%; box-sizing: border-box;">
            <p style="color: #2c3e50; font-size: 13px; font-style: italic; margin: 0 0 8px 0; line-height: 1.6; text-align: left; font-weight: 400; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;">
              Â« ${nextVerse.text} Â»
            </p>
            <p style="color: #667eea; font-size: 11px; margin: 0; font-weight: 600; text-align: left; letter-spacing: 0.3px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;">
              â€” ${nextVerse.reference}
            </p>
          </div>
        </div>
      `;
      document.getElementById('gameContainer').appendChild(levelUpDiv);
    }, 1000);
  }
}

// ============================================
// ğŸ¯ BOUCLIER DE PROGRESSION (CHAPITRES 1-14)
// Bord GRIS - 300px - AffichÃ© aux seuils de niveau
// ============================================
// Afficher l'Ã©cran de victoire du boss avec le message defeated
function showBossVictoryScreen(bossType, onClose) {
  // Convertir camelCase vers snake_case pour compatibilitÃ©
  const bossKey = bossType.replace(/([A-Z])/g, '_$1').toLowerCase();
  const bossTranslations = t(`bosses.${bossKey}`) || {};
  const phase1 = bossTranslations.phase_1 || '';
  const phase2 = bossTranslations.phase_2 || '';
  const phase3 = bossTranslations.phase_3 || '';
  const defeatedMessage = bossTranslations.defeated || '';
  
  const victoryDiv = document.createElement('div');
  victoryDiv.id = 'bossVictoryScreen';
  victoryDiv.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.85);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 450;
    animation: fadeIn 0.4s ease-in;
  `;
  
  victoryDiv.innerHTML = `
    <div style="
      width: 90%;
      max-width: 420px;
      max-height: 85vh;
      background: linear-gradient(to bottom, #ffffff 0%, #f8f9fa 100%);
      border-radius: 16px;
      box-shadow: 
        0 10px 40px rgba(0, 0, 0, 0.3),
        0 0 0 1px rgba(255, 215, 0, 0.2);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    ">
      <!-- En-tÃªte compact -->
      <div style="
        background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
        padding: 16px;
        text-align: center;
        border-bottom: 2px solid #f0c800;
        flex-shrink: 0;
      ">
        <div style="
          font-size: 24px;
          font-weight: 700;
          color: #1a1a1a;
          letter-spacing: 0.3px;
          margin-bottom: 4px;
        ">
          ${t('bosses.victory_title')}
        </div>
        <div style="
          font-size: 14px;
          color: #2a2a2a;
          font-weight: 600;
        ">
          ${bossTranslations.name || ''}
        </div>
      </div>
      
      <!-- Corps scrollable -->
      <div style="
        padding: 14px 16px;
        overflow-y: auto;
        flex: 1;
        scrollbar-width: thin;
        scrollbar-color: #ffd700 #f8f9fa;
      ">
        <!-- Phase 1 -->
        <div style="
          margin-bottom: 10px;
          border-left: 3px solid #e74c3c;
          padding: 10px 12px;
          background: #fff5f5;
          border-radius: 6px;
        ">
          <div style="
            font-size: 10px;
            font-weight: 700;
            color: #c0392b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
          ">
            ${t('bosses.phase_1')}
          </div>
          <div style="
            font-size: 11px;
            line-height: 1.5;
            color: #2c3e50;
            white-space: pre-wrap;
          ">
            ${phase1}
          </div>
        </div>
        
        <!-- Phase 2 -->
        <div style="
          margin-bottom: 10px;
          border-left: 3px solid #f39c12;
          padding: 10px 12px;
          background: #fffaf0;
          border-radius: 6px;
        ">
          <div style="
            font-size: 10px;
            font-weight: 700;
            color: #d68910;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
          ">
            ${t('bosses.phase_2')}
          </div>
          <div style="
            font-size: 11px;
            line-height: 1.5;
            color: #2c3e50;
            white-space: pre-wrap;
          ">
            ${phase2}
          </div>
        </div>
        
        <!-- Phase 3 -->
        <div style="
          margin-bottom: 10px;
          border-left: 3px solid #9b59b6;
          padding: 10px 12px;
          background: #f9f5ff;
          border-radius: 6px;
        ">
          <div style="
            font-size: 10px;
            font-weight: 700;
            color: #7d3c98;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
          ">
            ${t('bosses.phase_3')}
          </div>
          <div style="
            font-size: 11px;
            line-height: 1.5;
            color: #2c3e50;
            white-space: pre-wrap;
          ">
            ${phase3}
          </div>
        </div>
        
        <!-- Message de Victoire -->
        <div style="
          margin-top: 12px;
          padding: 12px;
          background: linear-gradient(135deg, #fff9e6 0%, #fffef7 100%);
          border: 2px solid #ffd700;
          border-radius: 8px;
          box-shadow: 0 2px 8px rgba(255, 215, 0, 0.15);
        ">
          <div style="
            font-size: 10px;
            font-weight: 700;
            color: #b8860b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
            text-align: center;
          ">
            ${t('bosses.spiritual_victory')}
          </div>
          <div style="
            font-size: 12px;
            line-height: 1.6;
            color: #2c3e50;
            text-align: center;
            white-space: pre-wrap;
          ">
            ${defeatedMessage}
          </div>
        </div>
      </div>
      
      <!-- Pied avec bouton -->
      <div style="
        padding: 12px 16px;
        background: #f8f9fa;
        border-top: 1px solid #e9ecef;
        text-align: center;
        flex-shrink: 0;
      ">
        <button id="bossVictoryContinue" style="
          background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
          color: #1a1a1a;
          border: none;
          padding: 12px 36px;
          border-radius: 20px;
          font-size: 14px;
          font-weight: 700;
          cursor: pointer;
          box-shadow: 0 3px 12px rgba(255, 215, 0, 0.3);
          transition: all 0.25s ease;
          letter-spacing: 0.5px;
          width: 100%;
          max-width: 240px;
        " onmouseover="
          this.style.transform='translateY(-2px)';
          this.style.boxShadow='0 5px 18px rgba(255, 215, 0, 0.4)';
        " onmouseout="
          this.style.transform='translateY(0)';
          this.style.boxShadow='0 3px 12px rgba(255, 215, 0, 0.3)';
        ">
          âœ¨ ${t('powerups.continue') || 'Continuer'}
        </button>
      </div>
    </div>
  `;
  
  document.body.appendChild(victoryDiv);
  
  // GÃ©rer le clic sur le bouton
  const continueBtn = document.getElementById('bossVictoryContinue');
  if(continueBtn) {
    continueBtn.onclick = () => {
      victoryDiv.remove();
      if(onClose) onClose();
    };
  }
  
  // Ajouter les animations CSS si elles n'existent pas dÃ©jÃ 
  if(!document.getElementById('bossVictoryAnimations')) {
    const style = document.createElement('style');
    style.id = 'bossVictoryAnimations';
    style.textContent = `
      @keyframes bossVictoryPulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.02); }
      }
      @keyframes glowPulse {
        0%, 100% { 
          text-shadow: 
            0 0 20px rgba(255, 215, 0, 0.8),
            0 0 40px rgba(255, 215, 0, 0.6),
            2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        50% { 
          text-shadow: 
            0 0 30px rgba(255, 215, 0, 1),
            0 0 60px rgba(255, 215, 0, 0.8),
            2px 2px 4px rgba(0, 0, 0, 0.8);
        }
      }
    `;
    document.head.appendChild(style);
  }
}

function showLevelUpMessage(levelInfo, previousState = 'playing', onClose = null) {
  
  // Utiliser le verset traduit depuis verses.rank au lieu du verset hardcodÃ©
  const rankVerse = t('verses.rank.' + levelInfo.id);
  const verse = rankVerse && rankVerse.text ? rankVerse : levelInfo.verse;
  
  const levelUpDiv = document.createElement('div');
  levelUpDiv.id = 'levelUpScreen';
  levelUpDiv.style.cssText = `
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 400;
    padding: 20px;
    box-sizing: border-box;
    animation: fadeIn 0.5s ease-in;
  `;
  levelUpDiv.innerHTML = `
    <div style="
      width: 320px;
      min-height: 420px;
      background: linear-gradient(145deg, #ffffff 0%, #fafafa 100%);
      border: 2px solid #c0c0c0;
      border-radius: 32px;
      box-shadow: 
        0 20px 60px rgba(192,192,192,0.25),
        0 8px 20px rgba(0,0,0,0.06),
        inset 0 1px 0 rgba(255,255,255,0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 42px 32px;
      box-sizing: border-box;
      gap: 22px;
      cursor: pointer;
      transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
    " onmouseover="
      this.style.transform='translateY(-4px)';
      this.style.boxShadow='0 25px 70px rgba(192,192,192,0.35), 0 10px 25px rgba(0,0,0,0.08), inset 0 1px 0 rgba(255,255,255,0.9)';
    " onmouseout="
      this.style.transform='translateY(0)';
      this.style.boxShadow='0 20px 60px rgba(192,192,192,0.25), 0 8px 20px rgba(0,0,0,0.06), inset 0 1px 0 rgba(255,255,255,0.9)';
    ">
      <!-- Badge Niveau -->
      <div style="
        background: linear-gradient(135deg, #e8e8e8 0%, #d0d0d0 100%);
        color: #333;
        padding: 10px 28px;
        border-radius: 24px;
        font-weight: 600;
        font-size: 15px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        letter-spacing: 0.5px;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        border: 1px solid #c0c0c0;
      ">
        ${levelInfo.icon} ${t('ui.level').toUpperCase()} ${levelInfo.id}
      </div>
      
      <!-- Titre -->
      <h3 style="
        color: #2a2a2a;
        font-size: 18px;
        margin: 0;
        font-weight: 500;
        text-align: center;
        line-height: 1.4;
        letter-spacing: -0.2px;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        text-wrap: balance;
        max-width: 100%;
      ">
        ${levelInfo.title}
      </h3>
      
      <!-- Message -->
      <p style="
        color: #666;
        font-size: 14px;
        line-height: 1.7;
        margin: 0;
        text-align: center;
        font-weight: 400;
        letter-spacing: 0;
        word-wrap: break-word;
        white-space: normal;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        text-wrap: balance;
        max-width: 100%;
      ">
        ${levelInfo.message}
      </p>
      
      <!-- Verset -->
      <div style="
        background: #fafafa;
        padding: 20px;
        border-radius: 20px;
        border: 1px solid rgba(192,192,192,0.3);
        width: 100%;
        box-sizing: border-box;
      ">
        <p style="
          color: #444;
          font-size: 13px;
          font-style: italic;
          margin: 0 0 12px 0;
          line-height: 1.7;
          text-align: center;
          font-weight: 400;
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
          word-wrap: break-word;
          overflow-wrap: break-word;
          text-wrap: pretty;
          max-width: 100%;
        ">
          ${verse.text}
        </p>
        <p style="
          color: #888;
          font-size: 11px;
          margin: 0;
          font-weight: 500;
          text-align: center;
          letter-spacing: 0.3px;
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        ">
          â€” ${verse.reference}
        </p>
      </div>
    </div>
  `;
  document.getElementById('gameContainer').appendChild(levelUpDiv);
  
  // Ajouter l'Ã©vÃ©nement click pour fermer et exÃ©cuter la callback
  const levelUpCard = levelUpDiv.querySelector('div');
  if (levelUpCard) {
    levelUpCard.addEventListener('click', function() {
      console.log('ğŸ–±ï¸ Click sur Ã©cran de niveau, onClose:', onClose ? 'dÃ©fini' : 'null');
      levelUpDiv.remove();
      state = previousState;
      if(state === 'playing') {
        lastTime = Date.now();
        requestAnimationFrame(loop);
      }
      // ExÃ©cuter la callback si elle existe (pour les niveaux bonus)
      if (onClose && typeof onClose === 'function') {
        console.log('ğŸ ExÃ©cution callback niveau bonus dans 300ms...');
        setTimeout(onClose, 300); // Petit dÃ©lai pour une transition fluide
      }
    });
  }
  
  // Jouer un son de rÃ©compense si disponible
  if (typeof playSound === 'function') {
    playSound('levelup');
  }
  
}

// ============================================
// â™¾ï¸ BOUCLIER INFINI (CHAPITRES 15+)
// Bord DORÃ‰ - 280px - AffichÃ© tous les 100 nuages
// ============================================
function showInfiniteVerse(previousState = 'playing') {
  
  // VÃ©rifier que getRandomVerse existe
  if (typeof getRandomVerse !== 'function') {
      state = previousState;
    return;
  }
  
  // Utiliser les versets de bible-verses.js
  const randomVerse = getRandomVerse();
  
  if (!randomVerse || !randomVerse.text) {
      state = previousState;
    return;
  }
  
  // Calculer le numÃ©ro du chapitre infini (tous les 100 nuages)
  const infiniteChapter = Math.floor(infiniteCloudsCleared / 100);
  
  const verseDiv = document.createElement('div');
  verseDiv.id = 'infiniteVerseDisplay';
  verseDiv.style.cssText = `
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 450;
    padding: 20px;
    box-sizing: border-box;
    animation: fadeIn 0.5s ease-in;
  `;
  verseDiv.innerHTML = `
    <div onclick="this.parentElement.remove(); state = '${previousState || 'playing'}';" style="
      width: 280px;
      height: 320px;
      background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
      border: 4px solid #d4af37;
      border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
      box-shadow: 0 15px 40px rgba(212,175,55,0.3), inset 0 2px 10px rgba(255,255,255,0.8);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 30px 20px;
      box-sizing: border-box;
      gap: 15px;
      cursor: pointer;
      transition: all 0.3s ease;
    " onmouseover="
      this.style.transform='scale(1.02)';
      this.style.boxShadow='0 20px 50px rgba(212,175,55,0.4), inset 0 2px 10px rgba(255,255,255,0.8)';
    " onmouseout="
      this.style.transform='scale(1)';
      this.style.boxShadow='0 15px 40px rgba(212,175,55,0.3), inset 0 2px 10px rgba(255,255,255,0.8)';
    ">
      <div style="font-size: 48px; margin-bottom: 5px;">â™¾ï¸</div>
      <div style="
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-weight: bold;
        font-size: 14px;
        box-shadow: 0 4px 12px rgba(102,126,234,0.4);
      ">
        ${t('treasure.infinite_chapter', {number: 15 + infiniteChapter})}
      </div>
      <p style="
        font-size: 15px;
        line-height: 1.5;
        color: #2d3748;
        margin: 10px 0;
        font-style: italic;
        text-align: center;
        text-wrap: pretty;
        max-width: 100%;
      ">${randomVerse.text}</p>
      <p style="
        font-size: 12px;
        color: #4a5568;
        margin: 0;
        font-weight: 500;
      ">â€” ${randomVerse.reference}</p>
    </div>
  `;
  document.getElementById('gameContainer').appendChild(verseDiv);
  
  // Jouer un son de rÃ©compense si disponible
  if (typeof playSound === 'function') {
    playSound('powerup');
  }
  
}

function initGame() {
  // VÃ©rifier si on est en mode test (niveau dÃ©jÃ  dÃ©fini manuellement)
  const isTestMode = level > 1 && score > 0;
  
  if (!isTestMode) {
    // Mode normal : restaurer les donnÃ©es sauvegardÃ©es
    if (gameData.highScore > 0) {
      score = gameData.highScore;
    }
    
    // Restaurer le niveau actuel basÃ© sur le nombre de nuages
    level = getCurrentLevel(gameData.totalCloudsDestroyed);
    
    // Restaurer les Ã©toiles
    if (gameData.starStock) {
      starCount = gameData.starStock;
    }
  } else {
    }
  
  // DÃ©marrer au niveau sauvegardÃ© (ou niveau 1 si c'est la premiÃ¨re fois)
  const savedLevelIndex = Math.max(0, level - 1);
  // VÃ©rifier que l'index est valide
  const startLevelIndex = Math.min(savedLevelIndex, LEVELS_CONFIG.length - 1);
  startLevel(startLevelIndex);
  
  // Mettre Ã  jour l'affichage des Ã©lÃ©ments UI
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const starsEl = document.getElementById('stars');
  const cloudsEl = document.getElementById('clouds');
  
  if (scoreEl) scoreEl.textContent = score;
  if (levelEl) levelEl.textContent = level;
  if (starsEl) starsEl.textContent = starCount;
  if (cloudsEl) cloudsEl.textContent = gameData.totalCloudsDestroyed;
  
}

// Initialiser le drapeau de langue au chargement
updateLanguageFlag();

// ============================================
// ğŸ“± PWA INSTALLATION & SERVICE WORKER
// ============================================

let deferredPrompt;

// Enregistrer le Service Worker
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/dove-of-hope-sky-blessing/sw.js')
      .then(registration => {
        console.log('âœ… Service Worker enregistrÃ©:', registration.scope);
      })
      .catch(error => {
        console.log('âŒ Erreur Service Worker:', error);
      });
    
    // Mettre Ã  jour le texte du bouton d'installation
    setTimeout(() => {
      const installBtnText = document.getElementById('installBtnText');
      if (installBtnText && typeof t === 'function') {
        installBtnText.textContent = t('ui.install') || 'INSTALLER';
      }
    }, 100);
  });
}

// Fonction pour dÃ©clencher l'installation PWA (appelÃ©e depuis le menu)
function triggerPWAInstall() {
  // Fermer le menu
  document.getElementById('pauseMenu').style.display='none';
  document.getElementById('pauseMenuOverlay').style.display='none';
  
  if (deferredPrompt) {
    // Chrome/Edge: utiliser l'API
    deferredPrompt.prompt();
    deferredPrompt.userChoice.then(result => {
      if (result.outcome === 'accepted') {
        console.log('âœ… App installÃ©e');
        // Cacher le bouton du menu aprÃ¨s installation
        const menuBtn = document.getElementById('installBtnMenu');
        if (menuBtn) menuBtn.style.display = 'none';
      }
      deferredPrompt = null;
    });
  } else {
    // Autre navigateur: afficher les instructions
    showInstallInstructions();
  }
}

// Afficher les instructions d'installation
function showInstallInstructions() {
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
  const isAndroid = /Android/.test(navigator.userAgent);
  
  let instructions = '';
  
  if (isIOS) {
    instructions = `
      <div style="text-align:center;padding:20px;">
        <div style="font-size:48px;margin-bottom:15px;">ğŸ“²</div>
        <div style="font-size:18px;margin-bottom:10px;font-weight:bold;">iOS</div>
        <div style="font-size:14px;line-height:1.6;">
          1ï¸âƒ£ ${t('ui.tap_share') || 'Appuyez sur'} <span style="font-size:20px;">â¬†ï¸</span><br>
          2ï¸âƒ£ ${t('ui.add_home') || 'Ajouter Ã  l\'Ã©cran d\'accueil'}<br>
          3ï¸âƒ£ ${t('ui.confirm') || 'Confirmer'}
        </div>
      </div>
    `;
  } else if (isAndroid) {
    instructions = `
      <div style="text-align:center;padding:20px;">
        <div style="font-size:48px;margin-bottom:15px;">ğŸ“²</div>
        <div style="font-size:18px;margin-bottom:10px;font-weight:bold;">Android</div>
        <div style="font-size:14px;line-height:1.6;">
          1ï¸âƒ£ Menu <span style="font-size:20px;">â‹®</span><br>
          2ï¸âƒ£ ${t('ui.install_app') || 'Installer l\'application'}<br>
          3ï¸âƒ£ ${t('ui.confirm') || 'Confirmer'}
        </div>
      </div>
    `;
  } else {
    instructions = `
      <div style="text-align:center;padding:20px;">
        <div style="font-size:48px;margin-bottom:15px;">ğŸ–¥ï¸</div>
        <div style="font-size:18px;margin-bottom:10px;font-weight:bold;">Desktop</div>
        <div style="font-size:14px;line-height:1.6;">
          ${t('ui.install_desktop') || 'Ouvrez dans Chrome/Edge pour installer'}<br>
          <span style="font-size:20px;">â‹®</span> â†’ ${t('ui.install_app') || 'Installer'}
        </div>
      </div>
    `;
  }
  
  const popup = document.createElement('div');
  popup.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    border-radius: 20px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    z-index: 10000;
    max-width: 90%;
    width: 350px;
  `;
  
  popup.innerHTML = `
    <button onclick="this.parentElement.remove()" style="
      position:absolute;
      top:10px;
      right:10px;
      background:rgba(0,0,0,0.1);
      color:#333;
      border:none;
      border-radius:50%;
      width:35px;
      height:35px;
      font-size:20px;
      cursor:pointer;
      font-weight:bold;
    ">âœ•</button>
    ${instructions}
  `;
  
  document.body.appendChild(popup);
}

// DÃ©tecter quand l'installation native est possible
window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  deferredPrompt = e;
  // Le bouton est dans le menu O/I, rien Ã  faire ici
});

// Cacher le bouton du menu aprÃ¨s installation
window.addEventListener('appinstalled', () => {
  console.log('âœ… App installÃ©e avec succÃ¨s');
  deferredPrompt = null;
  const menuBtn = document.getElementById('installBtnMenu');
  if (menuBtn) menuBtn.style.display = 'none';
});

requestAnimationFrame(loop);
</script>
</body>
</html>


